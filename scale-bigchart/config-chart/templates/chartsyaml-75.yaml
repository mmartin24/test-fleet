---
apiVersion: v1
kind: ConfigMap
metadata:
  name: foo-artifactory-ha-migration-scripts
  labels:
    app: artifactory-ha
    chart: artifactory-ha-2.2.9
    heritage: Helm
    release: foo
data:
  migrate.sh: "#!/bin/bash\n\n# Flags\nFLAG_Y=\"y\"\nFLAG_N=\"n\"\nFLAGS_Y_N=\"$FLAG_Y
    $FLAG_N\"\nFLAG_NOT_APPLICABLE=\"_NA_\"\n\nCURRENT_VERSION=$1\n\nWRAPPER_SCRIPT_TYPE_RPMDEB=\"RPMDEB\"\nWRAPPER_SCRIPT_TYPE_DOCKER_COMPOSE=\"DOCKERCOMPOSE\"\n\nSENSITIVE_KEY_VALUE=\"__sensitive_key_hidden___\"\n\n#
    Shared system keys\nSYS_KEY_SHARED_JFROGURL=\"shared.jfrogUrl\"\nSYS_KEY_SHARED_SECURITY_JOINKEY=\"shared.security.joinKey\"\nSYS_KEY_SHARED_SECURITY_MASTERKEY=\"shared.security.masterKey\"\n\nSYS_KEY_SHARED_NODE_ID=\"shared.node.id\"\nSYS_KEY_SHARED_JAVAHOME=\"shared.javaHome\"\n\nSYS_KEY_SHARED_DATABASE_TYPE=\"shared.database.type\"\nSYS_KEY_SHARED_DATABASE_TYPE_VALUE_POSTGRES=\"postgresql\"\nSYS_KEY_SHARED_DATABASE_DRIVER=\"shared.database.driver\"\nSYS_KEY_SHARED_DATABASE_URL=\"shared.database.url\"\nSYS_KEY_SHARED_DATABASE_USERNAME=\"shared.database.username\"\nSYS_KEY_SHARED_DATABASE_PASSWORD=\"shared.database.password\"\n\nSYS_KEY_SHARED_ELASTICSEARCH_URL=\"shared.elasticsearch.url\"\nSYS_KEY_SHARED_ELASTICSEARCH_USERNAME=\"shared.elasticsearch.username\"\nSYS_KEY_SHARED_ELASTICSEARCH_PASSWORD=\"shared.elasticsearch.password\"\nSYS_KEY_SHARED_ELASTICSEARCH_CLUSTERSETUP=\"shared.elasticsearch.clusterSetup\"\nSYS_KEY_SHARED_ELASTICSEARCH_UNICASTFILE=\"shared.elasticsearch.unicastFile\"\nSYS_KEY_SHARED_ELASTICSEARCH_CLUSTERSETUP_VALUE=\"YES\"\n\n#
    Define this in product specific script. Should contain the path to unitcast file\n#
    File used by insight server to write cluster active nodes info. This will be read
    by elasticsearch\n#SYS_KEY_SHARED_ELASTICSEARCH_UNICASTFILE_VALUE=\"\"\n\nSYS_KEY_RABBITMQ_ACTIVE_NODE_NAME=\"shared.rabbitMq.active.node.name\"\nSYS_KEY_RABBITMQ_ACTIVE_NODE_IP=\"shared.rabbitMq.active.node.ip\"\n\n#
    Filenames\nFILE_NAME_SYSTEM_YAML=\"system.yaml\"\nFILE_NAME_JOIN_KEY=\"join.key\"\nFILE_NAME_MASTER_KEY=\"master.key\"\nFILE_NAME_INSTALLER_YAML=\"installer.yaml\"\n\n#
    Global constants used in business logic\nNODE_TYPE_STANDALONE=\"standalone\"\nNODE_TYPE_CLUSTER_NODE=\"node\"\nNODE_TYPE_DATABASE=\"database\"\n\n#
    External(isable) databases \nDATABASE_POSTGRES=\"POSTGRES\"\nDATABASE_ELASTICSEARCH=\"ELASTICSEARCH\"\nDATABASE_RABBITMQ=\"RABBITMQ\"\n\nPOSTGRES_LABEL=\"PostgreSQL\"\nELASTICSEARCH_LABEL=\"Elasticsearch\"\nRABBITMQ_LABEL=\"Rabbitmq\"\n\nARTIFACTORY_LABEL=\"Artifactory\"\nJFMC_LABEL=\"Mission
    Control\"\nDISTRIBUTION_LABEL=\"Distribution\"\nXRAY_LABEL=\"Xray\"\n\nPOSTGRES_CONTAINER=\"postgres\"\nELASTICSEARCH_CONTAINER=\"elasticsearch\"\nRABBITMQ_CONTAINER=\"rabbitmq\"\nREDIS_CONTAINER=\"redis\"\n\n#Adding
    a small timeout before a read ensures it is positioned correctly in the screen\nread_timeout=0.5\n\n#
    Options related to data directory location\nPROMPT_DATA_DIR_LOCATION=\"Installation
    Directory\"\nKEY_DATA_DIR_LOCATION=\"installer.data_dir\"\n\nSYS_KEY_SHARED_NODE_HAENABLED=\"shared.node.haEnabled\"\nPROMPT_ADD_TO_CLUSTER=\"Are
    you adding an additional node to an existing product cluster?\"\nKEY_ADD_TO_CLUSTER=\"installer.ha\"\nVALID_VALUES_ADD_TO_CLUSTER=\"$FLAGS_Y_N\"\n\nMESSAGE_POSTGRES_INSTALL=\"The
    installer can install a $POSTGRES_LABEL database, or you can connect to an existing
    compatible $POSTGRES_LABEL database\\n(compatible databases: https://www.jfrog.com/confluence/display/JFROG/System+Requirements#SystemRequirements-RequirementsMatrix)\"\nPROMPT_POSTGRES_INSTALL=\"Do
    you want to install $POSTGRES_LABEL?\"\nKEY_POSTGRES_INSTALL=\"installer.install_postgresql\"\nVALID_VALUES_POSTGRES_INSTALL=\"$FLAGS_Y_N\"\n\n#
    Postgres connection details\nRPM_DEB_POSTGRES_HOME_DEFAULT=\"/var/opt/jfrog/postgres\"\nRPM_DEB_MESSAGE_STANDALONE_POSTGRES_DATA=\"$POSTGRES_LABEL
    home will have data and its configuration\"\nRPM_DEB_PROMPT_STANDALONE_POSTGRES_DATA=\"Type
    desired $POSTGRES_LABEL home location\"\nRPM_DEB_KEY_STANDALONE_POSTGRES_DATA=\"installer.postgresql.home\"\n\nMESSAGE_DATABASE_URL=\"Provide
    the database connection details\"\nPROMPT_DATABASE_URL(){\n    local databaseURlExample=\n
    \   case \"$PRODUCT_NAME\" in\n            $ARTIFACTORY_LABEL)\n                databaseURlExample=\"jdbc:postgresql://<IP_ADDRESS>:<PORT>/artifactory\"\n
    \           ;;\n            $JFMC_LABEL)\n                databaseURlExample=\"postgresql://<IP_ADDRESS>:<PORT>/mission_control?sslmode=disable\"\n
    \           ;;\n            $DISTRIBUTION_LABEL)\n                databaseURlExample=\"jdbc:postgresql://<IP_ADDRESS>:<PORT>/distribution?sslmode=disable\"\n
    \           ;;\n            $XRAY_LABEL)\n                databaseURlExample=\"postgres://<IP_ADDRESS>:<PORT>/xraydb?sslmode=disable\"\n
    \           ;;\n        esac\n    if [ -z \"$databaseURlExample\" ]; then\n        echo
    -n \"$POSTGRES_LABEL URL\" # For consistency with username and password\n        return\n
    \   fi\n    echo -n \"$POSTGRES_LABEL url. Example: [$databaseURlExample]\"\n}\nREGEX_DATABASE_URL(){\n
    \   local databaseURlExample=\n    case \"$PRODUCT_NAME\" in\n            $ARTIFACTORY_LABEL)\n
    \               databaseURlExample=\"jdbc:postgresql://.*/artifactory.*\"\n            ;;\n
    \           $JFMC_LABEL)\n                databaseURlExample=\"postgresql://.*/mission_control.*\"\n
    \           ;;\n            $DISTRIBUTION_LABEL)\n                databaseURlExample=\"jdbc:postgresql://.*/distribution.*\"\n
    \           ;;\n            $XRAY_LABEL)\n                databaseURlExample=\"postgres://.*/xraydb.*\"\n
    \           ;;\n        esac\n    echo -n \"^$databaseURlExample\\$\"\n}\nERROR_MESSAGE_DATABASE_URL=\"Invalid
    $POSTGRES_LABEL URL\"\nKEY_DATABASE_URL=\"$SYS_KEY_SHARED_DATABASE_URL\"\n#NOTE:
    It is important to display the label. Since the message may be hidden if URL is
    known\nPROMPT_DATABASE_USERNAME=\"$POSTGRES_LABEL username\"\nKEY_DATABASE_USERNAME=\"$SYS_KEY_SHARED_DATABASE_USERNAME\"\n#NOTE:
    It is important to display the label. Since the message may be hidden if URL is
    known\nPROMPT_DATABASE_PASSWORD=\"$POSTGRES_LABEL password\"\nKEY_DATABASE_PASSWORD=\"$SYS_KEY_SHARED_DATABASE_PASSWORD\"\nIS_SENSITIVE_DATABASE_PASSWORD=\"$FLAG_Y\"\n\nMESSAGE_STANDALONE_ELASTICSEARCH_INSTALL=\"The
    installer can install a $ELASTICSEARCH_LABEL database or you can connect to an
    existing compatible $ELASTICSEARCH_LABEL database\"\nPROMPT_STANDALONE_ELASTICSEARCH_INSTALL=\"Do
    you want to install $ELASTICSEARCH_LABEL?\"\nKEY_STANDALONE_ELASTICSEARCH_INSTALL=\"installer.install_elasticsearch\"\nVALID_VALUES_STANDALONE_ELASTICSEARCH_INSTALL=\"$FLAGS_Y_N\"\n\n#
    Elasticsearch connection details\nMESSAGE_ELASTICSEARCH_DETAILS=\"Provide the
    $ELASTICSEARCH_LABEL connection details\"\nPROMPT_ELASTICSEARCH_URL=\"$ELASTICSEARCH_LABEL
    URL\"\nKEY_ELASTICSEARCH_URL=\"$SYS_KEY_SHARED_ELASTICSEARCH_URL\"\n\nPROMPT_ELASTICSEARCH_USERNAME=\"$ELASTICSEARCH_LABEL
    username\"\nKEY_ELASTICSEARCH_USERNAME=\"$SYS_KEY_SHARED_ELASTICSEARCH_USERNAME\"\n\nPROMPT_ELASTICSEARCH_PASSWORD=\"$ELASTICSEARCH_LABEL
    password\"\nKEY_ELASTICSEARCH_PASSWORD=\"$SYS_KEY_SHARED_ELASTICSEARCH_PASSWORD\"\nIS_SENSITIVE_ELASTICSEARCH_PASSWORD=\"$FLAG_Y\"\n\n#
    Cluster related questions\nMESSAGE_CLUSTER_MASTER_KEY=\"Provide the cluster's
    master key. It can be found in the data directory of the first node under /etc/security/master.key\"\nPROMPT_CLUSTER_MASTER_KEY=\"Master
    Key\"\nKEY_CLUSTER_MASTER_KEY=\"$SYS_KEY_SHARED_SECURITY_MASTERKEY\"\nIS_SENSITIVE_CLUSTER_MASTER_KEY=\"$FLAG_Y\"\n\nMESSAGE_JOIN_KEY=\"The
    Join key is the secret key used to establish trust between services in the JFrog
    Platform.\\n(You can copy the Join Key from Admin > Security > Settings)\"\nPROMPT_JOIN_KEY=\"Join
    Key\"\nKEY_JOIN_KEY=\"$SYS_KEY_SHARED_SECURITY_JOINKEY\"\nIS_SENSITIVE_JOIN_KEY=\"$FLAG_Y\"\nREGEX_JOIN_KEY=\"^[a-zA-Z0-9]{16,}\\$\"\nERROR_MESSAGE_JOIN_KEY=\"Invalid
    Join Key\"\n\n# Rabbitmq related cluster information\nMESSAGE_RABBITMQ_ACTIVE_NODE_NAME=\"Provide
    an active ${RABBITMQ_LABEL} node name. Run the command [ hostname -s ] on any
    of the existing nodes in the product cluster to get this\"\nPROMPT_RABBITMQ_ACTIVE_NODE_NAME=\"${RABBITMQ_LABEL}
    active node name\"\nKEY_RABBITMQ_ACTIVE_NODE_NAME=\"$SYS_KEY_RABBITMQ_ACTIVE_NODE_NAME\"\n\n#
    Rabbitmq related cluster information (necessary only for docker-compose)\nPROMPT_RABBITMQ_ACTIVE_NODE_IP=\"${RABBITMQ_LABEL}
    active node ip\"\nKEY_RABBITMQ_ACTIVE_NODE_IP=\"$SYS_KEY_RABBITMQ_ACTIVE_NODE_IP\"\n\nMESSAGE_JFROGURL(){\n
    \   echo -e \"The JFrog URL allows ${PRODUCT_NAME} to connect to a JFrog Platform
    Instance.\\n(You can copy the JFrog URL from Admin > Security > Settings)\"\n}\nPROMPT_JFROGURL=\"JFrog
    URL\"\nKEY_JFROGURL=\"$SYS_KEY_SHARED_JFROGURL\"\nREGEX_JFROGURL=\"^https?://.*:{0,}[0-9]{0,4}\\$\"\nERROR_MESSAGE_JFROGURL=\"Invalid
    JFrog URL\"\n\n\n# Set this to FLAG_Y on upgrade\nIS_UPGRADE=\"${FLAG_N}\"\n\n#
    This belongs in JFMC but is the ONLY one that needs it so keeping it here for
    now. Can be made into a method and overridden if necessary\nMESSAGE_MULTIPLE_PG_SCHEME=\"Please
    setup $POSTGRES_LABEL with schema as described in https://www.jfrog.com/confluence/display/JFROG/Installing+Mission+Control\"\n\n_getMethodOutputOrVariableValue()
    {\n    unset EFFECTIVE_MESSAGE\n    local keyToSearch=$1\n    local effectiveMessage=\n
    \   local result=\"0\"\n    # logSilly \"Searching for method: [$keyToSearch]\"\n
    \   LC_ALL=C type \"$keyToSearch\" > /dev/null 2>&1 || result=\"$?\"\n    if [[
    \"$result\" == \"0\" ]]; then\n        # logSilly \"Found method for [$keyToSearch]\"\n
    \       EFFECTIVE_MESSAGE=\"$($keyToSearch)\"\n        return\n    fi\n    eval
    EFFECTIVE_MESSAGE=\\${$keyToSearch}\n    if [ ! -z \"$EFFECTIVE_MESSAGE\" ]; then\n
    \       return\n    fi\n    # logSilly \"Didn't find method or variable for [$keyToSearch]\"\n}\n\n\n#
    REF https://misc.flogisoft.com/bash/tip_colors_and_formatting\ncClear=\"\\e[0m\"\ncBlue=\"\\e[38;5;69m\"\ncRedDull=\"\\e[1;31m\"\ncYellow=\"\\e[1;33m\"\ncRedBright=\"\\e[38;5;197m\"\ncBold=\"\\e[1m\"\n\n\n_loggerGetModeRaw()
    {\n    local MODE=\"$1\"\n    case $MODE in\n    INFO)\n        printf \"\"\n
    \   ;;\n    DEBUG)\n        printf \"%s\" \"[${MODE}] \"\n    ;;\n    WARN)\n
    \       printf \"${cRedDull}%s%s${cClear}\" \"[\" \"${MODE}\" \"] \"\n    ;;\n
    \   ERROR)\n        printf \"${cRedBright}%s%s${cClear}\" \"[\" \"${MODE}\" \"]
    \"\n    ;;\n    esac\n}\n\n\n_loggerGetMode() {\n    local MODE=\"$1\"\n    case
    $MODE in\n    INFO)\n        printf \"${cBlue}%s%-5s%s${cClear}\" \"[\" \"${MODE}\"
    \"]\"\n    ;;\n    DEBUG)\n        printf \"%-7s\" \"[${MODE}]\"\n    ;;\n    WARN)\n
    \       printf \"${cRedDull}%s%-5s%s${cClear}\" \"[\" \"${MODE}\" \"]\"\n    ;;\n
    \   ERROR)\n        printf \"${cRedBright}%s%-5s%s${cClear}\" \"[\" \"${MODE}\"
    \"]\"\n    ;;\n    esac\n}\n\n# Capitalises the first letter of the message\n_loggerGetMessage()
    {\n    local originalMessage=\"$*\"\n    local firstChar=$(echo \"${originalMessage:0:1}\"
    | awk '{ print toupper($0) }')\n    local resetOfMessage=\"${originalMessage:1}\"\n
    \   echo \"$firstChar$resetOfMessage\"\n}\n\n# The spec also says content should
    be left-trimmed but this is not necessary in our case. We don't reach the limit.\n_loggerGetStackTrace()
    {\n    printf \"%s%-30s%s\" \"[\" \"$1:$2\" \"]\"\n}\n\n_loggerGetThread() {\n
    \   printf \"%s\" \"[main]\"\n}\n\n_loggerGetServiceType() {\n    printf \"%s%-5s%s\"
    \"[\" \"shell\" \"]\"\n}\n\n#Trace ID is not applicable to scripts\n_loggerGetTraceID()
    {\n    printf \"%s\" \"[]\"\n}\n\nlogRaw() {\n    echo \"\"\n    printf \"$1\"\n
    \   echo \"\"\n}\n\nlogBold(){\n    echo \"\"\n    printf \"${cBold}$1${cClear}\"\n
    \   echo \"\"\n}\n\n# The date binary works differently based on whether it is
    GNU/BSD\nis_date_supported=0\ndate --version > /dev/null 2>&1 || is_date_supported=1\nIS_GNU=$(echo
    $is_date_supported)\n\n_loggerGetTimestamp() {\n    if [ \"${IS_GNU}\" == \"0\"
    ]; then\n        echo -n $(date -u +%FT%T.%3NZ)\n    else\n        echo -n $(date
    -u +%FT%T.000Z)\n    fi\n}\n\n# https://www.shellscript.sh/tips/spinner/\n_spin()\n{\n
    \   spinner=\"/|\\\\-/|\\\\-\"\n    while :\n    do\n    for i in `seq 0 7`\n
    \   do\n        echo -n \"${spinner:$i:1}\"\n        echo -en \"\\010\"\n        sleep
    1\n    done\n    done\n}\n\nshowSpinner() {\n    # Start the Spinner:\n    _spin
    &\n    # Make a note of its Process ID (PID):\n    SPIN_PID=$!\n    # Kill the
    spinner on any signal, including our own exit.\n    trap \"kill -9 $SPIN_PID\"
    `seq 0 15` &> /dev/null || return 0\n}\n\nstopSpinner() {\n    local occurrences=$(ps
    -ef | grep -wc \"${SPIN_PID}\")\n    let \"occurrences+=0\"\n    # validate that
    it is present (2 since this search itself will show up in the results)\n    if
    [ $occurrences -gt 1 ]; then\n        kill -9 $SPIN_PID &>/dev/null || return
    0\n        wait $SPIN_ID &>/dev/null\n    fi\n}\n\n_getEffectiveMessage(){\n    local
    MESSAGE=\"$1\"\n    local MODE=${2-\"INFO\"}\n\n    if [ -z \"$CONTEXT\" ]; then\n
    \       CONTEXT=$(caller)\n    fi\n\n    _EFFECTIVE_MESSAGE=\n    if [ -z \"$LOG_BEHAVIOR_ADD_META\"
    ]; then\n        _EFFECTIVE_MESSAGE=\"$(_loggerGetModeRaw $MODE)$(_loggerGetMessage
    $MESSAGE)\"\n    else\n        local SERVICE_TYPE=\"script\"\n        local TRACE_ID=\"\"\n
    \       local THREAD=\"main\"\n        \n        local CONTEXT_LINE=$(echo \"$CONTEXT\"
    | awk '{print $1}')\n        local CONTEXT_FILE=$(echo \"$CONTEXT\" | awk -F\"/\"
    '{print $NF}')\n        \n        _EFFECTIVE_MESSAGE=\"$(_loggerGetTimestamp)
    $(_loggerGetServiceType) $(_loggerGetMode $MODE) $(_loggerGetTraceID) $(_loggerGetStackTrace
    $CONTEXT_FILE $CONTEXT_LINE) $(_loggerGetThread) - $(_loggerGetMessage $MESSAGE)\"\n
    \   fi\n    CONTEXT=\n}\n\n# Important - don't call any log method from this method.
    Will become an infinite loop. Use echo to debug\n_logToFile() {\n    local MODE=${1-\"INFO\"}\n
    \   local targetFile=\"$LOG_BEHAVIOR_ADD_REDIRECTION\"\n    # IF the file isn't
    passed, abort\n    if [ -z \"$targetFile\" ]; then\n        return\n    fi\n    #
    IF this is not being run in verbose mode and mode is debug or lower, abort\n    if
    [ \"${VERBOSE_MODE}\" != \"$FLAG_Y\" ] && [ \"${VERBOSE_MODE}\" != \"true\" ]
    && [ \"${VERBOSE_MODE}\" != \"debug\" ]; then\n        if [ \"$MODE\" == \"DEBUG\"
    ] || [ \"$MODE\" == \"SILLY\" ]; then\n            return\n        fi\n    fi\n\n
    \   # Create the file if it doesn't exist\n    if [ ! -f \"${targetFile}\" ];
    then\n        return\n        # touch $targetFile > /dev/null 2>&1 || true\n    fi\n
    \   # # Make it readable\n    # chmod 640 $targetFile > /dev/null 2>&1 || true\n\n
    \   # Log contents\n    printf \"%s\\n\" \"$_EFFECTIVE_MESSAGE\" >> \"$targetFile\"
    || true\n}\n\nlogger() {\n    if [ \"$LOG_BEHAVIOR_ADD_NEW_LINE\" == \"$FLAG_Y\"
    ]; then\n        echo \"\"\n    fi\n    _getEffectiveMessage \"$@\"\n    local
    MODE=${2-\"INFO\"}\n    printf \"%s\\n\" \"$_EFFECTIVE_MESSAGE\"\n    _logToFile
    \"$MODE\"\n}\n\nlogDebug(){\n    VERBOSE_MODE=${VERBOSE_MODE-\"false\"}\n    CONTEXT=$(caller)\n
    \   if [ \"${VERBOSE_MODE}\" == \"$FLAG_Y\" ] || [ \"${VERBOSE_MODE}\" == \"true\"
    ] || [ \"${VERBOSE_MODE}\" == \"debug\" ];then\n        logger \"$1\" \"DEBUG\"\n
    \   else\n        logger \"$1\" \"DEBUG\" >&6\n    fi\n    CONTEXT=\n}\n\nlogSilly(){\n
    \   VERBOSE_MODE=${VERBOSE_MODE-\"false\"}\n    CONTEXT=$(caller)\n    if [ \"${VERBOSE_MODE}\"
    == \"silly\" ];then\n        logger \"$1\" \"DEBUG\"\n    else\n        logger
    \"$1\" \"DEBUG\" >&6\n    fi\n    CONTEXT=\n}\n\nlogError() {\n    CONTEXT=$(caller)\n
    \   logger \"$1\" \"ERROR\"\n    CONTEXT=\n}\n\nerrorExit () {\n    CONTEXT=$(caller)\n
    \   logger \"$1\" \"ERROR\"\n    CONTEXT=\n    exit 1\n}\n\nwarn () {\n    CONTEXT=$(caller)\n
    \   logger \"$1\" \"WARN\"\n    CONTEXT=\n}\n\nnote () {\n    CONTEXT=$(caller)\n
    \   logger \"$1\" \"NOTE\"\n    CONTEXT=\n}\n\nbannerStart() {\n    title=$1\n
    \   echo\n    echo -e \"\\033[1m${title}\\033[0m\"\n    echo\n}\n\nbannerSection()
    {\n    title=$1\n    echo\n    echo -e \"******************************** ${title}
    ********************************\"\n    echo\n}\n\nbannerSubSection() {\n    title=$1\n
    \   echo\n    echo -e \"************** ${title} *******************\"\n    echo\n}\n\nbannerMessge()
    {\n    title=$1\n    echo\n    echo -e \"********************************\"\n
    \   echo -e \"${title}\"\n    echo -e \"********************************\"\n    echo\n}\n\nsetRed
    () {\n    local input=\"$1\"\n    echo -e \\\\033[31m${input}\\\\033[0m\n}\nsetGreen
    () {\n    local input=\"$1\"\n    echo -e \\\\033[32m${input}\\\\033[0m\n}\nsetYellow
    () {\n    local input=\"$1\"\n    echo -e \\\\033[33m${input}\\\\033[0m\n}\n\nlogger_addLinebreak
    () {\n    echo -e \"---\\n\"\n}\n\nbannerImportant() {\n    title=$1\n    local
    bold=\"\\033[1m\"\n    local noColour=\"\\033[0m\"\n    echo\n    echo -e \"${bold}########################################
    IMPORTANT ########################################${noColour}\"\n    echo -e \"${bold}${title}${noColour}\"\n
    \   echo -e \"${bold}###########################################################################################${noColour}\"\n
    \   echo\n}\n\nbannerEnd() {\n    #TODO pass a title and calculate length dynamically
    so that start and end look alike\n    echo\n    echo \"*****************************************************************************\"\n
    \   echo\n}\n\nbanner() {\n    title=$1\n    content=$2\n    bannerStart \"${title}\"\n
    \   echo -e \"$content\"\n}\n\n# The logic below helps us redirect content we'd
    normally hide to the log file. \n    #\n    # We have several commands which clutter
    the console with output and so use \n    # `cmd > /dev/null` - this redirects
    the command's output to null.\n    # \n    # However, the information we just
    hid maybe useful for support. Using the code pattern\n    # `cmd >&6` (instead
    of `cmd> >/dev/null` ), the command's output is hidden from the console \n    #
    but redirected to the installation log file\n    # \n\n#Default value of 6 is
    just null\nexec 6>>/dev/null\nredirectLogsToFile() {\n    echo \"\"\n    # local
    file=$1\n\n    # [ ! -z \"${file}\" ] || return 0\n\n    # local logDir=$(dirname
    \"$file\")\n\n    # if [ ! -f \"${file}\" ]; then\n    #     [ -d \"${logDir}\"
    ] || mkdir -p ${logDir} || \\\n    #     ( echo \"WARNING : Could not create parent
    directory (${logDir}) to redirect console log : ${file}\" ; return 0 )\n    #
    fi\n\n    # #6 now points to the log file\n    # exec 6>>${file}\n    # #reference
    https://unix.stackexchange.com/questions/145651/using-exec-and-tee-to-redirect-logs-to-stdout-and-a-log-file-in-the-same-time\n
    \   # exec 2>&1 > >(tee -a \"${file}\")\n}\n\n# Check if a give key contains any
    sensitive string as part of it\n# Based on the result, the caller can decide its
    value can be displayed or not\n#   Sample usage : isKeySensitive \"${key}\" &&
    displayValue=\"******\" || displayValue=${value}\nisKeySensitive(){\n    local
    key=$1\n    local sensitiveKeys=\"password|secret|key|token\"\n    \n    if [
    -z \"${key}\" ]; then\n        return 1\n    else\n        local lowercaseKey=$(echo
    \"${key}\" | tr '[:upper:]' '[:lower:]' 2>/dev/null)\n        [[ \"${lowercaseKey}\"
    =~ ${sensitiveKeys} ]] && return 0 || return 1\n    fi\n}\n\ngetPrintableValueOfKey(){\n
    \   local displayValue=\n    local key=\"$1\"\n    if [ -z \"$key\" ]; then\n
    \       # This is actually an incorrect usage of this method but any logging will
    cause unexpected content in the caller\n        echo -n \"\"\n        return\n
    \   fi\n\n    local value=\"$2\"\n    isKeySensitive \"${key}\" && displayValue=\"$SENSITIVE_KEY_VALUE\"
    || displayValue=\"${value}\"\n    echo -n $displayValue\n}\n\n_createConsoleLog(){\n
    \   if [ -z \"${JF_PRODUCT_HOME}\" ]; then\n        return\n    fi\n    local
    targetFile=\"${JF_PRODUCT_HOME}/var/log/console.log\"\n    mkdir -p \"${JF_PRODUCT_HOME}/var/log\"
    || true\n    if [ ! -f ${targetFile} ]; then\n        touch $targetFile > /dev/null
    2>&1 || true\n    fi\n    chmod 640 $targetFile > /dev/null 2>&1 || true\n}\n\n#
    Output from application's logs are piped to this method. It checks a configuration
    variable to determine if content should be logged to \n# the common console.log
    file\nredirectServiceLogsToFile() {\n\n    local result=\"0\"\n    # check if
    the function getSystemValue exists\n    LC_ALL=C type getSystemValue > /dev/null
    2>&1 || result=\"$?\"\n    if [[ \"$result\" != \"0\" ]]; then\n        warn \"Couldn't
    find the systemYamlHelper. Skipping log redirection\"\n        return 0\n    fi\n\n
    \   getSystemValue \"shared.consoleLog\" \"NOT_SET\"\n    if [[ \"${YAML_VALUE}\"
    == \"false\" ]]; then\n        logger \"Redirection is set to false. Skipping
    log redirection\"\n        return 0;\n    fi\n\n    if [ -z \"${JF_PRODUCT_HOME}\"
    ] || [ \"${JF_PRODUCT_HOME}\" == \"\" ]; then\n        warn \"JF_PRODUCT_HOME
    is unavailable. Skipping log redirection\"\n        return 0\n    fi\n\n    local
    targetFile=\"${JF_PRODUCT_HOME}/var/log/console.log\"\n    \n    _createConsoleLog\n\n
    \   while read -r line; do\n        printf '%s\\n' \"${line}\" >> $targetFile
    || return 0 # Don't want to log anything - might clutter the screen\n    done\n}\n\n##
    Display environment variables starting with JF_ along with its value\n## Value
    of sensitive keys will be displayed as \"******\"\n##\n## Sample Display :\n##\n##
    ========================\n## JF Environment variables\n## ========================\n##\n##
    JF_SHARED_NODE_ID                   : locahost\n## JF_SHARED_JOINKEY                   :
    ******\n##\n##\ndisplayEnv() {\n    local JFEnv=$(printenv | grep ^JF_ 2>/dev/null)\n
    \   local key=\n    local value=\n\n    if [ -z \"${JFEnv}\" ]; then\n        return\n
    \   fi\n\n    cat << ENV_START_MESSAGE\n\n========================\nJF Environment
    variables\n========================\nENV_START_MESSAGE\n\n    for entry in ${JFEnv};
    do\n        key=$(echo \"${entry}\" | awk -F'=' '{print $1}')\n        value=$(echo
    \"${entry}\" | awk -F'=' '{print $2}')\n\n        isKeySensitive \"${key}\" &&
    value=\"******\" || value=${value}\n        \n        printf \"\\n%-35s%s\" \"${key}\"
    \" : ${value}\"\n    done\n    echo;\n}\n\n_addLogRotateConfiguration() {\n    logDebug
    \"Method ${FUNCNAME[0]}\"\n    # mandatory inputs\n    local confFile=\"$1\"\n
    \   local logFile=\"$2\"\n\n    # Method available in _ioOperations.sh\n    LC_ALL=C
    type io_setYQPath > /dev/null 2>&1 || return 1\n\n    io_setYQPath\n\n    # Method
    available in _systemYamlHelper.sh\n    LC_ALL=C type getSystemValue > /dev/null
    2>&1 || return 1\n\n    local frequency=\"daily\"\n    local archiveFolder=\"archived\"\n\n
    \   local compressLogFiles=\n    getSystemValue \"shared.logging.rotation.compress\"
    \"true\"\n    if [[ \"${YAML_VALUE}\" == \"true\" ]]; then\n        compressLogFiles=\"compress\"\n
    \   fi\n\n    getSystemValue \"shared.logging.rotation.maxFiles\" \"10\"\n    local
    noOfBackupFiles=\"${YAML_VALUE}\"\n\n    getSystemValue \"shared.logging.rotation.maxSizeMb\"
    \"25\"\n    local sizeOfFile=\"${YAML_VALUE}M\"\n\n    logDebug \"Adding logrotate
    configuration for [$logFile] to [$confFile]\"\n\n    # Add configuration to file\n
    \   local confContent=$(cat << LOGROTATECONF\n$logFile {\n    $frequency\n    missingok\n
    \   rotate $noOfBackupFiles\n    $compressLogFiles\n    notifempty\n    olddir
    $archiveFolder\n    dateext\n    extension .log\n    dateformat -%Y-%m-%d\n    size
    ${sizeOfFile}\n}\nLOGROTATECONF\n) \n    echo \"${confContent}\" > ${confFile}
    || return 1\n}\n\n_operationIsBySameUser() {\n    local targetUser=\"$1\"\n    local
    currentUserID=$(id -u)\n    local currentUserName=$(id -un)\n\n    if [ $currentUserID
    == $targetUser ] || [ $currentUserName == $targetUser ]; then\n        echo -n
    \"yes\"\n    else   \n        echo -n \"no\"\n    fi\n}\n\n_addCronJobForLogrotate()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    \n    # Abort if logrotate is not
    available\n    [ \"$(io_commandExists 'crontab')\" != \"yes\" ] && warn \"cron
    is not available\" && return 1\n\n    # mandatory inputs\n    local productHome=\"$1\"\n
    \   local confFile=\"$2\"\n    local cronJobOwner=\"$3\"\n\n    # We want to use
    our binary if possible. It may be more recent than the one in the OS\n    local
    logrotateBinary=\"$productHome/app/third-party/logrotate/logrotate\"\n\n    if
    [ ! -f \"$logrotateBinary\" ]; then\n        logrotateBinary=\"logrotate\"\n        [
    \"$(io_commandExists 'logrotate')\" != \"yes\" ] && warn \"logrotate is not available\"
    && return 1\n    fi\n    local cmd=\"$logrotateBinary ${confFile} --state $productHome/var/etc/logrotate/logrotate-state\"
    #--verbose\n\n    id -u $cronJobOwner > /dev/null 2>&1 || { warn \"User $cronJobOwner
    does not exist. Aborting logrotate configuration\" && return 1; }\n    \n    #
    Remove the existing line\n    removeLogRotation \"$productHome\" \"$cronJobOwner\"
    || true\n\n    # Run logrotate daily at 23:55 hours\n    local cronInterval=\"55
    23 * * * $cmd\"\n\n    local standaloneMode=$(_operationIsBySameUser \"$cronJobOwner\")\n\n
    \   # If this is standalone mode, we cannot use -u - the user running this process
    may not have the necessary privileges\n    if [ \"$standaloneMode\" == \"no\"
    ]; then\n        (crontab -l -u $cronJobOwner 2>/dev/null; echo \"$cronInterval\")
    | crontab -u $cronJobOwner -\n    else\n        (crontab -l 2>/dev/null; echo
    \"$cronInterval\") | crontab -\n    fi\n}\n\n## Configure logrotate for a product\n##
    Failure conditions:\n## If logrotation could not be setup for some reason\n##
    Parameters:\n## $1: The product name\n## $2: The product home\n## Depends on global:
    none\n## Updates global: none\n## Returns: NA\n\nconfigureLogRotation() {\n    logDebug
    \"Method ${FUNCNAME[0]}\"\n\n    # mandatory inputs\n    local productName=\"$1\"\n
    \   if [ -z $productName ]; then\n        warn \"Incorrect usage. A product name
    is necessary for configuring log rotation\" && return 1\n    fi\n    \n    local
    productHome=\"$2\"\n    if [ -z $productHome ]; then\n        warn \"Incorrect
    usage. A product home folder is necessary for configuring log rotation\" && return
    1\n    fi\n\n    local logFile=\"${productHome}/var/log/console.log\"\n    if
    [[ $(uname) == \"Darwin\" ]]; then\n        logger \"Log rotation for [$logFile]
    has not been configured. Please setup manually\"\n        return 0\n    fi\n    \n
    \   local userID=\"$3\"\n    if [ -z $userID ]; then\n        warn \"Incorrect
    usage. A userID is necessary for configuring log rotation\" && return 1\n    fi\n\n
    \   local groupID=${4:-$userID}\n    local logConfigOwner=${5:-$userID}\n\n    logDebug
    \"Configuring log rotation as user [$userID], group [$groupID], effective cron
    User [$logConfigOwner]\"\n    \n    local errorMessage=\"Could not configure logrotate.
    Please configure log rotation of the file: [$logFile] manually\"\n\n    local
    confFile=\"${productHome}/var/etc/logrotate/logrotate.conf\"\n\n    # TODO move
    to recursive method\n    createDir \"${productHome}\" \"$userID\" \"$groupID\"
    || { warn \"${errorMessage}\" && return 1; }\n    createDir \"${productHome}/var\"
    \"$userID\" \"$groupID\" || { warn \"${errorMessage}\" && return 1; }\n    createDir
    \"${productHome}/var/log\" \"$userID\" \"$groupID\" || { warn \"${errorMessage}\"
    && return 1; }\n    createDir \"${productHome}/var/log/archived\" \"$userID\"
    \"$groupID\" || { warn \"${errorMessage}\" && return 1; }\n    \n    # TODO move
    to recursive method\n    createDir \"${productHome}/var/etc\"  \"$userID\" \"$groupID\"
    || { warn \"${errorMessage}\" && return 1; }\n    createDir \"${productHome}/var/etc/logrotate\"
    \"$logConfigOwner\" || { warn \"${errorMessage}\" && return 1; }\n\n    # conf
    file should be owned by the user running the script\n    createFile \"${confFile}\"
    \"${logConfigOwner}\" || { warn \"Could not create configuration file [$confFile]\"
    return 1; }\n\n    _addLogRotateConfiguration \"${confFile}\" \"${logFile}\" \"$userID\"
    \"$groupID\" || { warn \"${errorMessage}\" && return 1; }\n    _addCronJobForLogrotate
    \"${productHome}\" \"${confFile}\" \"${logConfigOwner}\" || { warn \"${errorMessage}\"
    && return 1; }\n}\n\n_pauseExecution() {\n    if [ \"${VERBOSE_MODE}\" == \"debug\"
    ]; then\n        \n        local breakPoint=\"$1\"\n        if [ ! -z \"$breakPoint\"
    ]; then\n            printf \"${cBlue}Breakpoint${cClear} [$breakPoint] \"\n            echo
    \"\"\n        fi\n        printf \"${cBlue}Press enter once you are ready to continue${cClear}\"\n
    \       read -s choice\n        echo \"\"\n    fi\n}\n\n# removeLogRotation \"$productHome\"
    \"$cronJobOwner\" || true\nremoveLogRotation() {\n    logDebug \"Method ${FUNCNAME[0]}\"\n
    \   if [[ $(uname) == \"Darwin\" ]]; then\n        logDebug \"Not implemented
    for Darwin.\"\n        return 0\n    fi\n    local productHome=\"$1\"\n    local
    cronJobOwner=\"$2\"\n    local standaloneMode=$(_operationIsBySameUser \"$cronJobOwner\")\n\n
    \   local confFile=\"${productHome}/var/etc/logrotate/logrotate.conf\"\n    \n
    \   if [ \"$standaloneMode\" == \"no\" ]; then\n        crontab -l -u $cronJobOwner
    2>/dev/null | grep -v \"$confFile\" | crontab -u $cronJobOwner -\n    else\n        crontab
    -l 2>/dev/null | grep -v \"$confFile\" | crontab -\n    fi\n}\n\n# NOTE: This
    method does not check the configuration to see if redirection is necessary.\n#
    This is intentional. If we don't redirect, tomcat logs might get redirected to
    a folder/file\n# that does not exist, causing the service itself to not start\nsetupTomcatRedirection()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    local consoleLog=\"${JF_PRODUCT_HOME}/var/log/console.log\"\n
    \   _createConsoleLog\n    export CATALINA_OUT=\"${consoleLog}\"\n}\n\nsetupScriptLogsRedirection()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    if [ -z \"${JF_PRODUCT_HOME}\"
    ]; then\n        logDebug \"No JF_PRODUCT_HOME. Returning\"\n        return\n
    \   fi\n    # Create the console.log file if it is not already present\n    #
    _createConsoleLog || true\n    # # Ensure any logs (logger/logError/warn) also
    get redirected to the console.log\n    # # Using installer.log as a temparory
    fix. Please change this to console.log once INST-291 is fixed\n    export LOG_BEHAVIOR_ADD_REDIRECTION=\"${JF_PRODUCT_HOME}/var/log/console.log\"\n
    \   export LOG_BEHAVIOR_ADD_META=\"$FLAG_Y\"\n}\n\n# Returns Y if this method
    is run inside a container\nisRunningInsideAContainer() {\n    if [ -f \"/.dockerenv\"
    ]; then\n        echo -n \"$FLAG_Y\"\n    else\n        echo -n \"$FLAG_N\"\n
    \   fi \n}\n\nPOSTGRES_USER=999\nNGINX_USER=104\nNGINX_GROUP=107\nES_USER=1000\nREDIS_USER=999\nMONGO_USER=999\nRABBITMQ_USER=999\nLOG_FILE_PERMISSION=640\nPID_FILE_PERMISSION=644\n\n#
    Copy file\ncopyFile(){\n    local source=$1\n    local target=$2\n    local mode=${3:-overwrite}\n
    \   local enableVerbose=${4:-\"${FLAG_N}\"}\n    local verboseFlag=\"\"\n\n    if
    [ ! -z \"${enableVerbose}\" ] && [ \"${enableVerbose}\" == \"${FLAG_Y}\" ]; then\n
    \       verboseFlag=\"-v\"\n    fi\n\n    if [[ ! ( $source && $target ) ]]; then\n
    \       warn \"Source and target is mandatory to copy file\"\n        return 1\n
    \   fi\n\n    if [[ -f \"${target}\" ]]; then\n        [[ \"$mode\" = \"overwrite\"
    ]] && ( cp ${verboseFlag} -f \"$source\" \"$target\" || errorExit \"Unable to
    copy file, command : cp -f ${source} ${target}\") || true\n    else\n        cp
    ${verboseFlag} -f \"$source\" \"$target\" || errorExit \"Unable to copy file,
    command : cp -f ${source} ${target}\"\n    fi\n}\n\n# Copy files recursively from
    given source directory to destination directory\n# This method wil copy but will
    NOT overwrite\n# Destination will be created if its not available\ncopyFilesNoOverwrite(){\n
    \   local src=$1\n    local dest=$2\n    local enableVerboseCopy=\"${3:-${FLAG_Y\"\n\n
    \   if [[ -z \"${src}\" || -z \"${dest}\" ]]; then\n        return\n    fi\n\n
    \   if [ -d \"${src}\" ] && [ \"$(ls -A ${src})\" ]; then\n        local relativeFilePath=\"\"\n
    \       local targetFilePath=\"\"\n\n        for file in $(find ${src} -type f
    2>/dev/null) ; do\n            # Derive relative path and attach it to destination
    \n            # Example : \n            #       src=/extra_config\n            #
    \      dest=/var/opt/jfrog/artifactory/etc\n            #       file=/extra_config/config.xml\n
    \           #       relativeFilePath=config.xml\n            #       targetFilePath=/var/opt/jfrog/artifactory/etc/config.xml\n
    \           relativeFilePath=${file/${src}/}\n            targetFilePath=${dest}${relativeFilePath}\n\n
    \           createDir \"$(dirname \"$targetFilePath\")\"\n            copyFile
    \"${file}\" \"${targetFilePath}\" \"no_overwrite\" \"${enableVerboseCopy}\"\n
    \       done\n    fi    \n}\n\n#    TODO : WINDOWS ?\n#  Check the max open files
    and open processes set on the system\ncheckULimits () {\n    local minMaxOpenFiles=${1:-32000}\n
    \   local minMaxOpenProcesses=${2:-1024}\n    local setValue=${3:-true}\n    local
    warningMsgForFiles=${4}\n    local warningMsgForProcesses=${5}\n\n    logger \"Checking
    open files and processes limits\"\n\n    local currentMaxOpenFiles=$(ulimit -n)\n
    \   logger \"Current max open files is $currentMaxOpenFiles\"\n    if [ ${currentMaxOpenFiles}
    != \"unlimited\" ] && [ \"$currentMaxOpenFiles\" -lt \"$minMaxOpenFiles\" ]; then\n
    \       if [ \"${setValue}\" ]; then\n            ulimit -n \"${minMaxOpenFiles}\"
    >/dev/null 2>&1 || warn \"Max number of open files $currentMaxOpenFiles is low!\"\n
    \           [ -z \"${warningMsgForFiles}\" ] || warn \"${warningMsgForFiles}\"\n
    \       else\n            errorExit \"Max number of open files $currentMaxOpenFiles,
    is too low. Cannot run the application!\"\n        fi\n    fi\n\n    local currentMaxOpenProcesses=$(ulimit
    -u)\n    logger \"Current max open processes is $currentMaxOpenProcesses\"\n    if
    [ \"$currentMaxOpenProcesses\" != \"unlimited\" ] && [ \"$currentMaxOpenProcesses\"
    -lt \"$minMaxOpenProcesses\" ]; then\n        if [ \"${setValue}\" ]; then\n            ulimit
    -u \"${minMaxOpenProcesses}\" >/dev/null 2>&1 || warn \"Max number of open files
    $currentMaxOpenFiles is low!\"\n            [ -z \"${warningMsgForProcesses}\"
    ] || warn \"${warningMsgForProcesses}\"\n        else\n            errorExit \"Max
    number of open files $currentMaxOpenProcesses, is too low. Cannot run the application!\"\n
    \       fi\n    fi\n}\n\ncreateDirs() {\n    local appDataDir=$1\n    local serviceName=$2\n
    \   local folders=\"backup bootstrap data etc logs work\"\n\n    [ -z \"${appDataDir}\"
    ]  && errorExit \"An application directory is mandatory to create its data structure\"
    \ || true\n    [ -z \"${serviceName}\" ] && errorExit \"A service name is mandatory
    to create service data structure\"         || true\n\n    for folder in ${folders}\n
    \   do\n        folder=${appDataDir}/${folder}/${serviceName}\n        if [ !
    -d \"${folder}\" ]; then\n            logger \"Creating folder : ${folder}\"\n
    \           mkdir -p \"${folder}\" || errorExit \"Failed to create ${folder}\"\n
    \       fi\n    done\n}\n\n\ntestReadWritePermissions () {\n    local dir_to_check=$1\n
    \   local error=false\n\n    [ -d ${dir_to_check} ] || errorExit \"'${dir_to_check}'
    is not a directory\"\n\n    local test_file=${dir_to_check}/test-permissions\n\n
    \   # Write file\n    if echo test > ${test_file} 1> /dev/null 2>&1; then\n        #
    Write succeeded. Testing read...\n        if cat ${test_file} > /dev/null; then\n
    \           rm -f ${test_file}\n        else\n            error=true\n        fi\n
    \   else\n        error=true\n    fi\n\n    if [ ${error} == true ]; then\n        return
    1\n    else\n        return 0\n    fi\n}\n\n# Test directory has read/write permissions
    for current user\ntestDirectoryPermissions () {\n    local dir_to_check=$1\n    local
    error=false\n\n    [ -d ${dir_to_check}  ] || errorExit \"'${dir_to_check}' is
    not a directory\"\n\n    local u_id=$(id -u)\n    local id_str=\"id ${u_id}\"\n\n
    \   logger \"Testing directory ${dir_to_check} has read/write permissions for
    user ${id_str}\"\n\n    if ! testReadWritePermissions ${dir_to_check}; then\n
    \       error=true\n    fi\n\n    if [ \"${error}\" == true ]; then\n        local
    stat_data=$(stat -Lc \"Directory: %n, permissions: %a, owner: %U, group: %G\"
    ${dir_to_check})\n        logger \"###########################################################\"\n
    \       logger \"${dir_to_check} DOES NOT have proper permissions for user ${id_str}\"\n
    \       logger \"${stat_data}\"\n        logger \"Mounted directory must have
    read/write permissions for user ${id_str}\"\n        logger \"###########################################################\"\n
    \       errorExit \"Directory ${dir_to_check} has bad permissions for user ${id_str}\"\n
    \   fi\n    logger \"Permissions for ${dir_to_check} are good\"\n}\n\n# Utility
    method to create a directory path recursively with chown feature as\n# Failure
    conditions:\n## Exits if unable to create a directory\n# Parameters:\n## $1: Root
    directory from where the path can be created\n## $2: List of recursive child directories
    seperated by space\n## $3: user who should own the directory. Optional\n## $4:
    group who should own the directory. Optional\n# Depends on global: none\n# Updates
    global: none\n# Returns: NA\n#\n# Usage:\n# createRecursiveDir \"/opt/jfrog/product/var\"
    \"bootstrap tomcat lib\" \"user_name\" \"group_name\"\ncreateRecursiveDir(){\n
    \   local rootDir=$1\n    local pathDirs=$2\n    local user=$3\n    local group=${4:-${user\n
    \   local fullPath=\n\n    [ ! -z \"${rootDir}\" ] || return 0\n\n    createDir
    \"${rootDir}\" \"${user}\" \"${group}\"\n\n    [ ! -z \"${pathDirs}\" ] || return
    0\n\n    fullPath=${rootDir}\n\n    for dir in ${pathDirs}; do\n        fullPath=${fullPath}/${dir}\n
    \       createDir \"${fullPath}\" \"${user}\" \"${group}\"\n    done\n}\n\n# Utility
    method to create a directory\n# Failure conditions:\n## Exits if unable to create
    a directory\n# Parameters:\n## $1: directory to create\n## $2: user who should
    own the directory. Optional\n## $3: group who should own the directory. Optional\n#
    Depends on global: none\n# Updates global: none\n# Returns: NA\n\ncreateDir(){\n
    \   local dirName=\"$1\"\n    local printMessage=no\n    logSilly \"Method ${FUNCNAME[0]}
    invoked with [$dirName]\"\n    [ -z \"${dirName}\" ] && return\n    \n    logDebug
    \"Attempting to create ${dirName}\"\n    mkdir -p \"${dirName}\" || errorExit
    \"Unable to create directory: [${dirName}]\"\n    local userID=\"$2\"\n    local
    groupID=${3:-$userID}\n\n    # If UID/GID is passed, chown the folder\n    if
    [ ! -z \"$userID\" ] && [ ! -z \"$groupID\" ]; then\n        # Earlier, this line
    would have returned 1 if it failed. Now it just warns. \n        # This is intentional.
    Earlier, this line would NOT be reached if the folder already existed. \n        #
    Since it will always come to this line and the script may be running as a non-root
    user, this method will just warn if\n        # setting permissions fails (so as
    to not affect any existing flows)\n        io_setOwnershipNonRecursive \"$dirName\"
    \"$userID\" \"$groupID\" || warn \"Could not set owner of [$dirName] to [$userID:$groupID]\"\n
    \   fi\n    # logging message to print created dir with user and group\n    local
    logMessage=${4:-$printMessage}\n    if [[ \"${logMessage}\" == \"yes\" ]]; then\n
    \       logger \"Successfully created directory [${dirName}].  Owner: [${userID}:${groupID}]\"\n
    \   fi\n}\n\nremoveSoftLinkAndCreateDir () {\n    local dirName=\"$1\"\n    local
    userID=\"$2\"\n    local groupID=\"$3\"\n    local logMessage=\"$4\"\n    removeSoftLink
    \"${dirName}\"\n    createDir \"${dirName}\" \"${userID}\" \"${groupID}\" \"${logMessage}\"\n}\n\n#
    Utility method to remove a soft link\nremoveSoftLink () {\n    local dirName=\"$1\"\n
    \   if [[ -L \"${dirName}\" ]]; then\n        targetLink=$(readlink -f \"${dirName}\")\n
    \       logger \"Removing the symlink [${dirName}] pointing to [${targetLink}]\"\n
    \       rm -f \"${dirName}\"\n    fi\n}\n\n# Check Directory exist in the path\ncheckDirExists
    () {\n    local directoryPath=\"$1\"\n\n    [[ -d \"${directoryPath}\" ]] && echo
    -n \"true\" || echo -n \"false\"\n}\n\n\n# Utility method to create a file\n#
    Failure conditions:\n# Parameters:\n## $1: file to create\n# Depends on global:
    none\n# Updates global: none\n# Returns: NA\n\ncreateFile(){\n    local fileName=\"$1\"\n
    \   logSilly \"Method ${FUNCNAME[0]} [$fileName]\"\n    [ -f \"${fileName}\" ]
    && return 0\n    touch \"${fileName}\" || return 1\n\n    local userID=\"$2\"\n
    \   local groupID=${3:-$userID}\n\n    # If UID/GID is passed, chown the folder\n
    \   if [ ! -z \"$userID\" ] && [ ! -z \"$groupID\" ]; then\n        io_setOwnership
    \"$fileName\" \"$userID\" \"$groupID\" || return 1\n    fi\n}\n\n# Check File
    exist in the filePath\n# IMPORTANT- DON'T ADD LOGGING to this method\ncheckFileExists
    () {\n    local filePath=\"$1\"\n\n    [[ -f \"${filePath}\" ]] && echo -n \"true\"
    || echo -n \"false\"\n}\n\n# Check for directories contains any (files or sub
    directories)\n# IMPORTANT- DON'T ADD LOGGING to this method\ncheckDirContents
    () {\n    local directoryPath=\"$1\"\n    if [[ \"$(ls -1 \"${directoryPath}\"
    | wc -l)\" -gt 0 ]]; then\n        echo -n \"true\"\n    else\n        echo -n
    \"false\"\n    fi\n}\n\n# Check contents exist in directory\n# IMPORTANT- DON'T
    ADD LOGGING to this method\ncheckContentExists () {\n    local source=\"$1\"\n\n
    \   if [[ \"$(checkDirContents \"${source}\")\" != \"true\" ]]; then\n        echo
    -n \"false\"\n    else\n        echo -n \"true\"\n    fi\n}\n\n# Resolve the variable\n#
    IMPORTANT- DON'T ADD LOGGING to this method\nevalVariable () {\n    local output=\"$1\"\n
    \   local input=\"$2\"\n\n    eval \"${output}\"=\\${\"${input}\"}\n    eval echo
    \\${\"${output}\"}\n}\n\n# Usage: if [ \"$(io_commandExists 'curl')\" == \"yes\"
    ]\n# IMPORTANT- DON'T ADD LOGGING to this method\nio_commandExists() {\n    local
    commandToExecute=\"$1\"\n    hash \"${commandToExecute}\" 2>/dev/null\n    local
    rt=$?\n    if [ \"$rt\" == 0 ]; then echo -n \"yes\"; else echo -n \"no\"; fi\n}\n\n#
    Usage: if [ \"$(io_curlExists)\" != \"yes\" ]\n# IMPORTANT- DON'T ADD LOGGING
    to this method\nio_curlExists() {\n    io_commandExists \"curl\"\n}\n\n\nio_hasMatch()
    {\n    logSilly \"Method ${FUNCNAME[0]}\"\n    local result=0\n    logDebug \"Executing
    [echo \\\"$1\\\" | grep \\\"$2\\\" >/dev/null 2>&1]\"\n    echo \"$1\" | grep
    \"$2\" >/dev/null 2>&1 || result=1\n    return $result\n}\n\n# Utility method
    to check if the string passed (usually a connection url) corresponds to this machine
    itself\n# Failure conditions: None\n# Parameters:\n## $1: string to check against\n#
    Depends on global: none\n# Updates global: IS_LOCALHOST with value \"yes/no\"\n#
    Returns: NA\n\nio_getIsLocalhost() {\n    logSilly \"Method ${FUNCNAME[0]}\"\n
    \   IS_LOCALHOST=\"$FLAG_N\"\n    local inputString=\"$1\"\n    logDebug \"Parsing
    [$inputString] to check if we are dealing with this machine itself\"\n\n    io_hasMatch
    \"$inputString\" \"localhost\" && {\n        logDebug \"Found localhost. Returning
    [$FLAG_Y]\"\n        IS_LOCALHOST=\"$FLAG_Y\" && return;\n    } || logDebug \"Did
    not find match for localhost\"\n    \n    local hostIP=$(io_getPublicHostIP)\n
    \   io_hasMatch \"$inputString\" \"$hostIP\" && {\n        logDebug \"Found $hostIP.
    Returning [$FLAG_Y]\"\n        IS_LOCALHOST=\"$FLAG_Y\" && return;\n    } || logDebug
    \"Did not find match for $hostIP\"\n    \n    local hostID=$(io_getPublicHostID)\n
    \   io_hasMatch \"$inputString\" \"$hostID\" && {\n        logDebug \"Found $hostID.
    Returning [$FLAG_Y]\"\n        IS_LOCALHOST=\"$FLAG_Y\" && return;\n    } || logDebug
    \"Did not find match for $hostID\"\n    \n    local hostName=$(io_getPublicHostName)\n
    \   io_hasMatch  \"$inputString\" \"$hostName\" && {\n        logDebug \"Found
    $hostName. Returning [$FLAG_Y]\"\n        IS_LOCALHOST=\"$FLAG_Y\" && return;\n
    \   } || logDebug \"Did not find match for $hostName\"\n    \n}\n\n# Usage: if
    [ \"$(io_tarExists)\" != \"yes\" ]\n# IMPORTANT- DON'T ADD LOGGING to this method\nio_tarExists()
    {\n    io_commandExists \"tar\"\n}\n\n# IMPORTANT- DON'T ADD LOGGING to this method\nio_getPublicHostIP()
    {\n    local OS_TYPE=$(uname)\n    local publicHostIP=\n    if [ \"${OS_TYPE}\"
    == \"Darwin\" ]; then\n        ipStatus=$(ifconfig en0 | grep \"status\" | awk
    '{print$2}')\n        if [ \"${ipStatus}\" == \"active\" ]; then\n            publicHostIP=$(ifconfig
    en0 | grep inet | grep -v inet6 | awk '{print $2}')\n        else\n            errorExit
    \"Host IP could not be resolved!\"\n        fi\n    elif [ \"${OS_TYPE}\" == \"Linux\"
    ]; then\n        publicHostIP=$(hostname -i 2>/dev/null || echo \"127.0.0.1\")\n
    \   fi\n    publicHostIP=$(echo \"${publicHostIP}\" | awk '{print $1}')\n    echo
    -n \"${publicHostIP}\"\n}\n\n# Will return the short host name (up to the first
    dot)\n# IMPORTANT- DON'T ADD LOGGING to this method\nio_getPublicHostName() {\n
    \   echo -n \"$(hostname -s)\"\n}\n\n# Will return the full host name (use this
    as much as possible)\n# IMPORTANT- DON'T ADD LOGGING to this method\nio_getPublicHostID()
    {\n    echo -n \"$(hostname)\"\n}\n\n# Utility method to backup a file\n# Failure
    conditions: NA\n# Parameters: filePath\n# Depends on global: none,\n# Updates
    global: none\n# Returns: NA\nio_backupFile() {\n    logSilly \"Method ${FUNCNAME[0]}\"\n
    \   fileName=\"$1\"\n    if [ ! -f \"${filePath}\" ]; then\n        logDebug \"No
    file: [${filePath}] to backup\"\n        return\n    fi\n    dateTime=$(date +\"%Y-%m-%d-%H-%M-%S\")\n
    \   targetFileName=\"${fileName}.backup.${dateTime}\"\n    yes | \\cp -f \"$fileName\"
    \"${targetFileName}\"\n    logger \"File [${fileName}] backedup as [${targetFileName}]\"\n}\n\n#
    Reference https://stackoverflow.com/questions/4023830/how-to-compare-two-strings-in-dot-separated-version-format-in-bash/4025065#4025065\nis_number()
    {\n    case \"$BASH_VERSION\" in\n        3.1.*)\n            PATTERN='\\^\\[0-9\\]+\\$'\n
    \           ;;\n        *)\n            PATTERN='^[0-9]+$'\n            ;;\n    esac\n\n
    \   [[ \"$1\" =~ $PATTERN ]]\n}\n\nio_compareVersions() {\n    if [[ $# != 2 ]]\n
    \   then\n        echo \"Usage: min_version current minimum\"\n        return\n
    \   fi\n\n    A=\"${1%%.*}\"\n    B=\"${2%%.*}\"\n\n    if [[ \"$A\" != \"$1\"
    && \"$B\" != \"$2\" && \"$A\" == \"$B\" ]]\n    then\n        io_compareVersions
    \"${1#*.}\" \"${2#*.}\"\n    else\n        if is_number \"$A\" && is_number \"$B\"\n
    \       then\n            if [[ \"$A\" -eq \"$B\" ]]; then\n                echo
    \"0\"\n            elif [[ \"$A\" -gt \"$B\" ]]; then\n                echo \"1\"\n
    \           elif [[ \"$A\" -lt \"$B\" ]]; then\n                echo \"-1\"\n
    \           fi\n        fi\n    fi\n}\n\n# Reference https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable\n#
    Strip all leading and trailing spaces\n# IMPORTANT- DON'T ADD LOGGING to this
    method\nio_trim() {\n    local var=\"$1\"\n    # remove leading whitespace characters\n
    \   var=\"${var#\"${var%%[![:space:]]*}\"}\"\n    # remove trailing whitespace
    characters\n    var=\"${var%\"${var##*[![:space:]]}\"}\"\n    echo -n \"$var\"\n}\n\n#
    temporary function will be removing it ASAP\n# search for string and replace text
    in file\nreplaceText_migration_hook () {\n    local regexString=\"$1\"\n    local
    replaceText=\"$2\"\n    local file=\"$3\"\n\n    if [[ \"$(checkFileExists \"${file}\")\"
    != \"true\" ]]; then\n        return\n    fi\n    if [[ $(uname) == \"Darwin\"
    ]]; then\n        sed -i '' -e \"s/${regexString}/${replaceText}/\" \"${file}\"
    || warn \"Failed to replace the text in ${file}\"\n    else\n        sed -i -e
    \"s/${regexString}/${replaceText}/\" \"${file}\" || warn \"Failed to replace the
    text in ${file}\"\n    fi\n}\n\n# search for string and replace text in file\nreplaceText
    () {\n    local regexString=\"$1\"\n    local replaceText=\"$2\"\n    local file=\"$3\"\n\n
    \   if [[ \"$(checkFileExists \"${file}\")\" != \"true\" ]]; then\n        return\n
    \   fi\n    if [[ $(uname) == \"Darwin\" ]]; then\n        sed -i '' -e \"s#${regexString}#${replaceText}#\"
    \"${file}\" || warn \"Failed to replace the text in ${file}\"\n    else\n        sed
    -i -e \"s#${regexString}#${replaceText}#\" \"${file}\" || warn \"Failed to replace
    the text in ${file}\"\n        logDebug \"Replaced [$regexString] with [$replaceText]
    in [$file]\"\n    fi\n}\n\n# search for string and prepend text in file\nprependText
    () {\n    local regexString=\"$1\"\n    local text=\"$2\"\n    local file=\"$3\"\n\n
    \   if [[ \"$(checkFileExists \"${file}\")\" != \"true\" ]]; then\n        return\n
    \   fi\n    if [[ $(uname) == \"Darwin\" ]]; then\n        sed -i '' -e '/'\"${regexString}\"'/i\\'$'\\n\\\\'\"${text}\"''$'\\n'
    \"${file}\" || warn \"Failed to prepend the text in ${file}\"\n    else\n        sed
    -i -e '/'\"${regexString}\"'/i\\'$'\\n\\\\'\"${text}\"''$'\\n' \"${file}\" ||
    warn \"Failed to prepend the text in ${file}\"\n    fi\n}\n\n# add text to beginning
    of the file\naddText () {\n    local text=\"$1\"\n    local file=\"$2\"\n\n    if
    [[ \"$(checkFileExists \"${file}\")\" != \"true\" ]]; then\n        return\n    fi\n
    \   if [[ $(uname) == \"Darwin\" ]]; then\n        sed -i '' -e '1s/^/'\"${text}\"'\\'$'\\n/'
    \"${file}\" || warn \"Failed to add the text in ${file}\"\n    else\n        sed
    -i -e '1s/^/'\"${text}\"'\\'$'\\n/' \"${file}\" || warn \"Failed to add the text
    in ${file}\"\n    fi\n}\n\nio_replaceString () {\n    local value=\"$1\"\n    local
    firstString=\"$2\"\n    local secondString=\"$3\"\n    local separator=${4:-\"/\"}\n
    \   local updateValue=\n    if [[ $(uname) == \"Darwin\" ]]; then\n        updateValue=$(echo
    \"${value}\" | sed \"s${separator}${firstString}${separator}${secondString}${separator}\")\n
    \   else\n        updateValue=$(echo \"${value}\" | sed \"s${separator}${firstString}${separator}${secondString}${separator}\")\n
    \   fi\n    echo -n \"${updateValue}\"\n}\n\n_findYQ() {\n    # logSilly \"Method
    ${FUNCNAME[0]}\" (Intentionally not logging. Does not add value)\n    local parentDir=\"$1\"\n
    \   if [ -z \"$parentDir\" ]; then\n        return\n    fi\n    logDebug \"Executing
    command [find \"${parentDir}\" -name third-party -type d]\"\n    local yq=$(find
    \"${parentDir}\" -name third-party -type d)\n    if [ -d \"${yq}/yq\" ]; then\n
    \       export YQ_PATH=\"${yq}/yq\"\n    fi\n}\n\n\nio_setYQPath() {\n    # logSilly
    \"Method ${FUNCNAME[0]}\" (Intentionally not logging. Does not add value)\n    if
    [ \"$(io_commandExists 'yq')\" == \"yes\" ]; then\n        return\n    fi\n    \n
    \   if [ ! -z \"${JF_PRODUCT_HOME}\" ] && [ -d \"${JF_PRODUCT_HOME}\" ]; then\n
    \       _findYQ \"${JF_PRODUCT_HOME}\"\n    fi\n    \n    if [ -z \"${YQ_PATH}\"
    ] && [ ! -z \"${COMPOSE_HOME}\" ] && [ -d \"${COMPOSE_HOME}\" ]; then\n        _findYQ
    \"${COMPOSE_HOME}\"\n    fi\n    # TODO We can remove this block after all the
    code is restructured.\n    if [ -z \"${YQ_PATH}\" ] && [ ! -z \"${SCRIPT_HOME}\"
    ] && [ -d \"${SCRIPT_HOME}\" ]; then\n        _findYQ \"${SCRIPT_HOME}\"\n    fi\n
    \   \n}\n\nio_getLinuxDistribution() {\n    LINUX_DISTRIBUTION=\n\n    # Make
    sure running on Linux\n    [ $(uname -s) != \"Linux\" ] && return\n\n    # Find
    out what Linux distribution we are on\n\n    cat /etc/*-release | grep -i Red
    >/dev/null 2>&1 && LINUX_DISTRIBUTION=RedHat || true\n\n    # OS 6.x\n    cat
    /etc/issue.net | grep Red >/dev/null 2>&1 && LINUX_DISTRIBUTION=RedHat || true\n\n
    \   # OS 7.x\n    cat /etc/*-release | grep -i centos >/dev/null 2>&1 && LINUX_DISTRIBUTION=CentOS
    && LINUX_DISTRIBUTION_VER=\"7\" || true\n\n    # OS 8.x\n    grep -q -i \"release
    8\" /etc/redhat-release >/dev/null 2>&1 && LINUX_DISTRIBUTION_VER=\"8\" || true\n\n
    \   # OS 7.x\n    grep -q -i \"release 7\" /etc/redhat-release >/dev/null 2>&1
    && LINUX_DISTRIBUTION_VER=\"7\" || true\n\n    # OS 6.x\n    grep -q -i \"release
    6\" /etc/redhat-release >/dev/null 2>&1 && LINUX_DISTRIBUTION_VER=\"6\" || true\n\n
    \   cat /etc/*-release | grep -i Red | grep -i 'VERSION=7' >/dev/null 2>&1 &&
    LINUX_DISTRIBUTION=RedHat && LINUX_DISTRIBUTION_VER=\"7\" || true\n\n    cat /etc/*-release
    | grep -i debian >/dev/null 2>&1 && LINUX_DISTRIBUTION=Debian || true\n\n    cat
    /etc/*-release | grep -i ubuntu >/dev/null 2>&1 && LINUX_DISTRIBUTION=Ubuntu ||
    true\n}\n\n## Utility method to check ownership of folders/files\n## Failure conditions:\n
    \   ## If invoked with incorrect inputs - FATAL\n    ## If file is not owned by
    the user & group\n## Parameters:\n    ## user\n    ## group\n    ## folder to
    chown    \n## Globals: none\n## Returns: none\n## NOTE: The method does NOTHING
    if the OS is Mac\nio_checkOwner () {\n    logSilly \"Method ${FUNCNAME[0]}\"\n
    \   local osType=$(uname)\n    \n    if [ \"${osType}\" != \"Linux\" ]; then\n
    \       logDebug \"Unsupported OS. Skipping check\"\n        return 0\n    fi\n\n
    \   local file_to_check=$1\n    local user_id_to_check=$2\n    \n\n    if [ -z
    \"$user_id_to_check\" ] || [ -z \"$file_to_check\" ]; then\n        errorExit
    \"Invalid invocation of method. Missing mandatory inputs\"\n    fi\n\n    local
    group_id_to_check=${3:-$user_id_to_check}\n    local check_user_name=${4:-\"no\"}\n\n
    \   logDebug \"Checking permissions on [$file_to_check] for user [$user_id_to_check]
    & group [$group_id_to_check]\"\n\n    local stat=\n\n    if [ \"${check_user_name}\"
    == \"yes\" ]; then\n        stat=( $(stat -Lc \"%U %G\" ${file_to_check}) )\n
    \   else\n        stat=( $(stat -Lc \"%u %g\" ${file_to_check}) )\n    fi\n\n
    \   local user_id=${stat[0]}\n    local group_id=${stat[1]}\n\n    if [[ \"${user_id}\"
    != \"${user_id_to_check}\" ]] || [[ \"${group_id}\" != \"${group_id_to_check}\"
    ]] ; then\n        logDebug \"Ownership mismatch. [${file_to_check}] is not owned
    by [${user_id_to_check}:${group_id_to_check}]\"\n        return 1\n    else\n
    \       return 0\n    fi\n}\n\n## Utility method to change ownership of a file/folder
    - NON recursive\n## Failure conditions:\n    ## If invoked with incorrect inputs
    - FATAL\n    ## If chown operation fails - returns 1\n## Parameters: \n    ##
    user\n    ## group\n    ## file to chown    \n## Globals: none\n## Returns: none\n##
    NOTE: The method does NOTHING if the OS is Mac\n\nio_setOwnershipNonRecursive()
    {\n    \n    local osType=$(uname)\n    if [ \"${osType}\" != \"Linux\" ]; then\n
    \       return\n    fi\n\n    local targetFile=$1\n    local user=$2\n\n    if
    [ -z \"$user\" ] || [ -z \"$targetFile\" ]; then\n        errorExit \"Invalid
    invocation of method. Missing mandatory inputs\"\n    fi\n\n    local group=${3:-$user}\n
    \   logDebug \"Method ${FUNCNAME[0]}. Executing [chown ${user}:${group} ${targetFile}]\"\n
    \   chown ${user}:${group} ${targetFile} || return 1\n}\n\n## Utility method to
    change ownership of a file. \n## IMPORTANT \n## If being called on a folder, should
    ONLY be called for fresh folders or may cause performance issues\n## Failure conditions:\n
    \   ## If invoked with incorrect inputs - FATAL\n    ## If chown operation fails
    - returns 1\n## Parameters: \n    ## user\n    ## group\n    ## file to chown
    \   \n## Globals: none\n## Returns: none\n## NOTE: The method does NOTHING if
    the OS is Mac\n\nio_setOwnership() {\n    \n    local osType=$(uname)\n    if
    [ \"${osType}\" != \"Linux\" ]; then\n        return\n    fi\n\n    local targetFile=$1\n
    \   local user=$2\n\n    if [ -z \"$user\" ] || [ -z \"$targetFile\" ]; then\n
    \       errorExit \"Invalid invocation of method. Missing mandatory inputs\"\n
    \   fi\n\n    local group=${3:-$user}\n    logDebug \"Method ${FUNCNAME[0]}. Executing
    [chown -R ${user}:${group} ${targetFile}]\"\n    chown -R ${user}:${group} ${targetFile}
    || return 1\n}\n\n## Utility method to create third party folder structure necessary
    for Postgres\n## Failure conditions:\n## If creation of directory or assigning
    permissions fails\n## Parameters: none\n## Globals:\n## POSTGRESQL_DATA_ROOT\n##
    Returns: none\n## NOTE: The method does NOTHING if the folder already exists\nio_createPostgresDir()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    [ -z \"${POSTGRESQL_DATA_ROOT}\"
    ] && return 0\n\n    logDebug \"Property [${POSTGRESQL_DATA_ROOT}] exists. Proceeding\"\n\n
    \   createDir \"${POSTGRESQL_DATA_ROOT}/data\"\n    io_setOwnership  \"${POSTGRESQL_DATA_ROOT}\"
    \"${POSTGRES_USER}\" \"${POSTGRES_USER}\" || errorExit \"Setting ownership of
    [${POSTGRESQL_DATA_ROOT}] to [${POSTGRES_USER}:${POSTGRES_USER}] failed\"\n}\n\n##
    Utility method to create third party folder structure necessary for Nginx\n##
    Failure conditions:\n## If creation of directory or assigning permissions fails\n##
    Parameters: none\n## Globals:\n## NGINX_DATA_ROOT\n## Returns: none\n## NOTE:
    The method does NOTHING if the folder already exists\nio_createNginxDir() {\n
    \   logDebug \"Method ${FUNCNAME[0]}\"\n    [ -z \"${NGINX_DATA_ROOT}\" ] && return
    0\n\n    logDebug \"Property [${NGINX_DATA_ROOT}] exists. Proceeding\"\n\n    createDir
    \"${NGINX_DATA_ROOT}\"\n    io_setOwnership  \"${NGINX_DATA_ROOT}\" \"${NGINX_USER}\"
    \"${NGINX_GROUP}\" || errorExit \"Setting ownership of [${NGINX_DATA_ROOT}] to
    [${NGINX_USER}:${NGINX_GROUP}] failed\"\n}\n\n## Utility method to create third
    party folder structure necessary for ElasticSearch\n## Failure conditions:\n##
    If creation of directory or assigning permissions fails\n## Parameters: none\n##
    Globals:\n## ELASTIC_DATA_ROOT\n## Returns: none\n## NOTE: The method does NOTHING
    if the folder already exists\nio_createElasticSearchDir() {\n    logDebug \"Method
    ${FUNCNAME[0]}\"\n    [ -z \"${ELASTIC_DATA_ROOT}\" ] && return 0\n\n    logDebug
    \"Property [${ELASTIC_DATA_ROOT}] exists. Proceeding\"\n\n    createDir \"${ELASTIC_DATA_ROOT}/data\"\n
    \   io_setOwnership  \"${ELASTIC_DATA_ROOT}\" \"${ES_USER}\" \"${ES_USER}\" ||
    errorExit \"Setting ownership of [${ELASTIC_DATA_ROOT}] to [${ES_USER}:${ES_USER}]
    failed\"\n}\n\n## Utility method to create third party folder structure necessary
    for Redis\n## Failure conditions:\n## If creation of directory or assigning permissions
    fails\n## Parameters: none\n## Globals:\n## REDIS_DATA_ROOT\n## Returns: none\n##
    NOTE: The method does NOTHING if the folder already exists\nio_createRedisDir()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    [ -z \"${REDIS_DATA_ROOT}\" ] &&
    return 0\n\n    logDebug \"Property [${REDIS_DATA_ROOT}] exists. Proceeding\"\n\n
    \   createDir \"${REDIS_DATA_ROOT}\"\n    io_setOwnership  \"${REDIS_DATA_ROOT}\"
    \"${REDIS_USER}\" \"${REDIS_USER}\" || errorExit \"Setting ownership of [${REDIS_DATA_ROOT}]
    to [${REDIS_USER}:${REDIS_USER}] failed\"\n}\n\n## Utility method to create third
    party folder structure necessary for Mongo\n## Failure conditions:\n## If creation
    of directory or assigning permissions fails\n## Parameters: none\n## Globals:\n##
    MONGODB_DATA_ROOT\n## Returns: none\n## NOTE: The method does NOTHING if the folder
    already exists\nio_createMongoDir() {\n    logDebug \"Method ${FUNCNAME[0]}\"\n
    \   [ -z \"${MONGODB_DATA_ROOT}\" ] && return 0\n\n    logDebug \"Property [${MONGODB_DATA_ROOT}]
    exists. Proceeding\"\n\n    createDir \"${MONGODB_DATA_ROOT}/logs\"\n    createDir
    \"${MONGODB_DATA_ROOT}/configdb\"\n    createDir \"${MONGODB_DATA_ROOT}/db\"\n
    \   io_setOwnership  \"${MONGODB_DATA_ROOT}\" \"${MONGO_USER}\" \"${MONGO_USER}\"
    || errorExit \"Setting ownership of [${MONGODB_DATA_ROOT}] to [${MONGO_USER}:${MONGO_USER}]
    failed\"\n}\n\n## Utility method to create third party folder structure necessary
    for RabbitMQ\n## Failure conditions:\n## If creation of directory or assigning
    permissions fails\n## Parameters: none\n## Globals:\n## RABBITMQ_DATA_ROOT\n##
    Returns: none\n## NOTE: The method does NOTHING if the folder already exists\nio_createRabbitMQDir()
    {\n    logDebug \"Method ${FUNCNAME[0]}\"\n    [ -z \"${RABBITMQ_DATA_ROOT}\"
    ] && return 0\n\n    logDebug \"Property [${RABBITMQ_DATA_ROOT}] exists. Proceeding\"\n\n
    \   createDir \"${RABBITMQ_DATA_ROOT}\"\n    io_setOwnership  \"${RABBITMQ_DATA_ROOT}\"
    \"${RABBITMQ_USER}\" \"${RABBITMQ_USER}\" || errorExit \"Setting ownership of
    [${RABBITMQ_DATA_ROOT}] to [${RABBITMQ_USER}:${RABBITMQ_USER}] failed\"\n}\n\n#
    Add or replace a property in provided properties file\naddOrReplaceProperty()
    {\n    local propertyName=$1\n    local propertyValue=$2\n    local propertiesPath=$3\n
    \   local delimiter=${4:-\"=\"}\n\n    # Return if any of the inputs are empty\n
    \   [[ -z \"$propertyName\"   || \"$propertyName\"   == \"\" ]] && return\n    [[
    -z \"$propertyValue\"  || \"$propertyValue\"  == \"\" ]] && return\n    [[ -z
    \"$propertiesPath\" || \"$propertiesPath\" == \"\" ]] && return\n\n    grep \"^${propertyName}\\s*${delimiter}.*$\"
    ${propertiesPath} > /dev/null 2>&1\n    [ $? -ne 0 ] && echo -e \"\\n${propertyName}${delimiter}${propertyValue}\"
    >> ${propertiesPath}\n    sed -i -e \"s|^${propertyName}\\s*${delimiter}.*$|${propertyName}${delimiter}${propertyValue}|g;\"
    ${propertiesPath}\n}\n\n# Set property only if its not set\nio_setPropertyNoOverride(){\n
    \   local propertyName=$1\n    local propertyValue=$2\n    local propertiesPath=$3\n\n
    \   # Return if any of the inputs are empty\n    [[ -z \"$propertyName\"   ||
    \"$propertyName\"   == \"\" ]] && return\n    [[ -z \"$propertyValue\"  || \"$propertyValue\"
    \ == \"\" ]] && return\n    [[ -z \"$propertiesPath\" || \"$propertiesPath\" ==
    \"\" ]] && return\n\n    grep \"^${propertyName}:\" ${propertiesPath} > /dev/null
    2>&1\n    if [ $? -ne 0 ]; then\n        echo -e \"${propertyName}: ${propertyValue}\"
    >> ${propertiesPath} || warn \"Setting property ${propertyName}: ${propertyValue}
    in [ ${propertiesPath} ] failed\"\n    else\n        logger \"Skipping update
    of property : ${propertyName}\" >&6\n    fi\n}\n\n# Add a line to a file if it
    doesn't already exist\naddLine() {\n    local line_to_add=$1\n    local target_file=$2\n
    \   logger \"Trying to add line $1 to $2\" >&6 2>&1\n    cat \"$target_file\"
    | grep -F \"$line_to_add\" -wq >&6 2>&1\n    if [ $? != 0  ]; then\n        logger
    \"Line does not exist and will be added\" >&6 2>&1\n        echo $line_to_add
    >> $target_file || errorExit \"Could not update $target_file\"\n    fi    \n}\n\n#
    Utility method to check if a value (first paramter) exists in an array (2nd parameter)\n#
    1st parameter \"value to find\"\n# 2nd parameter \"The array to search in. Please
    pass a string with each value separated by space\"\n# Example: containsElement
    \"y\" \"y Y n N\"\ncontainsElement () {\n    local searchElement=$1\n    local
    searchArray=($2)\n    local found=1\n    for elementInIndex in \"${searchArray[@]}\";do\n
    \   if [[ $elementInIndex == $searchElement ]]; then\n        found=0\n    fi\n
    \   done\n    return $found\n}\n\n# Utility method to get user's choice\n# 1st
    parameter \"what to ask the user\"\n# 2nd parameter \"what choices to accept,
    separated by spaces\"\n# 3rd parameter \"what is the default choice (to use if
    the user simply presses Enter)\"\n# Example 'getUserChoice \"Are you feeling lucky?
    Punk!\" \"y n Y N\" \"y\"'\ngetUserChoice(){\n    configureLogOutput\n    read_timeout=${read_timeout:-0.5}\n
    \   local choice=\"na\"\n    local text_to_display=$1\n    local choices=$2\n
    \   local default_choice=$3\n    users_choice=\n\n    until containsElement \"$choice\"
    \"$choices\"; do\n        echo \"\";echo \"\";\n        sleep $read_timeout #This
    ensures correct placement of the question.\n        read -p  \"$text_to_display
    :\" choice\n        : ${choice:=$default_choice}\n    done\n    users_choice=$choice\n
    \   echo -e \"\\n$text_to_display: $users_choice\" >&6\n    sleep $read_timeout
    #This ensures correct logging\n}\n\nsetFilePermission () {\n    local permission=$1\n
    \   local file=$2\n    chmod \"${permission}\" \"${file}\" || warn \"Setting permission
    ${permission} to file [ ${file} ] failed\"\n}\n\n\n#setting required paths\nsetAppDir
    (){\n    SCRIPT_DIR=$(dirname $0)\n    SCRIPT_HOME=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\"
    && pwd)\"\n    APP_DIR=\"`cd \"${SCRIPT_HOME}\";pwd`\"\n}\n\nZIP_TYPE=\"zip\"\nCOMPOSE_TYPE=\"compose\"\nHELM_TYPE=\"helm\"\nRPM_TYPE=\"rpm\"\nDEB_TYPE=\"debian\"\n\nsourceScript
    () {\n    local file=\"$1\"\n\n    [ ! -z \"${file}\" ] || errorExit \"target
    file is not passed to source a file\"\n\n    if [ ! -f \"${file}\" ]; then\n        errorExit
    \"${file} file is not found\"\n    else\n        source \"${file}\" || errorExit
    \"Unable to source ${file}, please check if the user ${USER} has permissions to
    perform this action\"\n    fi\n}\n# Source required helpers\ninitHelpers () {\n
    \   local systemYamlHelper=\"${APP_DIR}/systemYamlHelper.sh\"\n    local thirdPartyDir=$(find
    ${APP_DIR}/.. -name third-party -type d)\n    export YQ_PATH=\"${thirdPartyDir}/yq\"\n
    \   LIBXML2_PATH=\"${thirdPartyDir}/libxml2/bin/xmllint\"\n    export LD_LIBRARY_PATH=\"${thirdPartyDir}/libxml2/lib\"\n
    \   sourceScript \"${systemYamlHelper}\"\n}\n# Check migration info yaml file
    available in the path\ncheckMigrationInfoYaml () {\n\n    if [[ -f \"${APP_DIR}/migrationHelmInfo.yaml\"
    ]]; then\n        MIGRATION_SYSTEM_YAML_INFO=\"${APP_DIR}/migrationHelmInfo.yaml\"\n
    \       INSTALLER=\"${HELM_TYPE}\"\n    elif [[ -f \"${APP_DIR}/migrationZipInfo.yaml\"
    ]]; then\n        MIGRATION_SYSTEM_YAML_INFO=\"${APP_DIR}/migrationZipInfo.yaml\"\n
    \       INSTALLER=\"${ZIP_TYPE}\"\n    elif [[ -f \"${APP_DIR}/migrationRpmInfo.yaml\"
    ]]; then\n        MIGRATION_SYSTEM_YAML_INFO=\"${APP_DIR}/migrationRpmInfo.yaml\"\n
    \       INSTALLER=\"${RPM_TYPE}\"\n    elif [[ -f \"${APP_DIR}/migrationDebInfo.yaml\"
    ]]; then\n        MIGRATION_SYSTEM_YAML_INFO=\"${APP_DIR}/migrationDebInfo.yaml\"\n
    \       INSTALLER=\"${DEB_TYPE}\"\n    elif [[ -f \"${APP_DIR}/migrationComposeInfo.yaml\"
    ]]; then\n        MIGRATION_SYSTEM_YAML_INFO=\"${APP_DIR}/migrationComposeInfo.yaml\"\n
    \       INSTALLER=\"${COMPOSE_TYPE}\"\n    else\n        errorExit \"File migration
    Info yaml does not exist in [${APP_DIR}]\"\n    fi\n}\n\nretrieveYamlValue ()
    {\n    local yamlPath=\"$1\"\n    local value=\"$2\"\n    local output=\"$3\"\n
    \   local message=\"$4\"\n\n    [[ -z \"${yamlPath}\" ]] && errorExit \"yamlPath
    is mandatory to get value from ${MIGRATION_SYSTEM_YAML_INFO}\"\n\n    getYamlValue
    \"${yamlPath}\" \"${MIGRATION_SYSTEM_YAML_INFO}\" \"false\"\n    value=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${value}\" ]]; then\n        if [[ \"${output}\" == \"Warning\"
    ]]; then\n            warn \"Empty value for ${yamlPath} in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n
    \       elif [[ \"${output}\" == \"Skip\" ]]; then\n            return\n        else\n
    \           errorExit \"${message}\"\n        fi\n    fi\n}\n\ncheckEnv () {\n
    \   \n    if [[ \"${INSTALLER}\" == \"${ZIP_TYPE}\" ]]; then\n        # check
    Environment JF_PRODUCT_HOME is set before migration\n        NEW_DATA_DIR=\"$(evalVariable
    \"NEW_DATA_DIR\" \"JF_PRODUCT_HOME\")\"\n        if [[ -z \"${NEW_DATA_DIR}\"
    ]]; then\n            errorExit \"Environment variable JF_PRODUCT_HOME is not
    set, this is required to perform Migration\"\n        fi\n        # appending
    var directory to $JF_PRODUCT_HOME\n        NEW_DATA_DIR=\"${NEW_DATA_DIR}/var\"\n
    \   elif [[ \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        getCustomDataDir_hook\n
    \       NEW_DATA_DIR=\"${OLD_DATA_DIR}\"\n        if [[ -z \"${NEW_DATA_DIR}\"
    ]] && [[  -z \"${OLD_DATA_DIR}\" ]]; then\n            errorExit \"Could not find
    ${PROMPT_DATA_DIR_LOCATION} to perform Migration\"\n        fi\n    else\n        #
    check Environment JF_ROOT_DATA_DIR is set before migration\n        OLD_DATA_DIR=\"$(evalVariable
    \"OLD_DATA_DIR\" \"JF_ROOT_DATA_DIR\")\"\n        # check Environment JF_ROOT_DATA_DIR
    is set before migration\n        NEW_DATA_DIR=\"$(evalVariable \"NEW_DATA_DIR\"
    \"JF_ROOT_DATA_DIR\")\"\n        if [[ -z \"${NEW_DATA_DIR}\" ]] && [[  -z \"${OLD_DATA_DIR}\"
    ]]; then\n            errorExit \"Could not find ${PROMPT_DATA_DIR_LOCATION} to
    perform Migration\"\n        fi\n            # appending var directory to $JF_PRODUCT_HOME\n
    \           NEW_DATA_DIR=\"${NEW_DATA_DIR}/var\"\n    fi\n    \n}\n\ngetDataDir
    () {\n\n    if [[ \"${INSTALLER}\" == \"${ZIP_TYPE}\" || \"${INSTALLER}\" == \"${COMPOSE_TYPE}\"||
    \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        checkEnv\n    else\n        getCustomDataDir_hook\n
    \       NEW_DATA_DIR=\"`cd \"${APP_DIR}\"/../../;pwd`\"\n        NEW_DATA_DIR=\"${NEW_DATA_DIR}/var\"\n
    \   fi\n}\n\n# Retrieve Product name from MIGRATION_SYSTEM_YAML_INFO\ngetProduct
    () {\n    retrieveYamlValue \"migration.product\" \"${YAML_VALUE}\" \"Fail\" \"Empty
    value under ${yamlPath} in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n    PRODUCT=\"${YAML_VALUE}\"\n
    \   PRODUCT=$(echo \"${PRODUCT}\" | tr '[:upper:]' '[:lower:]' 2>/dev/null)\n
    \   if [[ \"${PRODUCT}\" != \"artifactory\" && \"${PRODUCT}\" != \"distribution\"
    && \"${PRODUCT}\" != \"xray\" ]]; then\n        errorExit \"migration.product
    in [${MIGRATION_SYSTEM_YAML_INFO}] is not correct, please set based on product
    as ARTIFACTORY or DISTRIBUTION\"\n    fi\n    if [[ \"${INSTALLER}\" == \"${HELM_TYPE}\"
    ]]; then\n        JF_USER=\"${PRODUCT}\"\n    fi\n}\n# Compare product version
    with minProductVersion and maxProductVersion\nmigrateCheckVersion () {\n    local
    productVersion=\"$1\"\n    local minProductVersion=\"$2\"\n    local maxProductVersion=\"$3\"\n
    \   local productVersion618=\"6.18.0\"\n    local unSupportedProductVersions7=(\"7.2.0
    7.2.1\")\n\n    if [[ \"$(io_compareVersions \"${productVersion}\" \"${maxProductVersion}\")\"
    -eq 0 || \"$(io_compareVersions \"${productVersion}\" \"${maxProductVersion}\")\"
    -eq 1 ]]; then\n        logger \"Migration not necessary. ${PRODUCT} is already
    ${productVersion}\"\n        exit 11\n    elif [[ \"$(io_compareVersions \"${productVersion}\"
    \"${minProductVersion}\")\" -eq 0 || \"$(io_compareVersions \"${productVersion}\"
    \"${minProductVersion}\")\" -eq 1 ]]; then\n        if [[ (\"$(io_compareVersions
    \"${productVersion}\" \"${productVersion618}\")\" -eq 0 || \"$(io_compareVersions
    \"${productVersion}\" \"${productVersion618}\")\" -eq 1) && \" ${unSupportedProductVersions7[@]}
    \" =~ \" ${CURRENT_VERSION} \" ]]; then\n            touch /tmp/error;\n            errorExit
    \"Current ${PRODUCT} version (${productVersion}) does not support migration to
    ${CURRENT_VERSION}\"\n        else\n            bannerStart \"Detected ${PRODUCT}
    ${productVersion}, initiating migration\"\n        fi\n    else\n        logger
    \"Current ${PRODUCT} ${productVersion} version is not supported for migration\"\n
    \       exit 1\n    fi\n}\n\ngetProductVersion () {\n    local minProductVersion=\"$1\"\n
    \   local maxProductVersion=\"$2\"\n    local newfilePath=\"$3\"\n    local oldfilePath=\"$4\"\n
    \   local propertyInDocker=\"$5\"\n    local property=\"$6\"\n    local productVersion=\n
    \   local status=\n\n    if [[ \"$INSTALLER\" == \"${COMPOSE_TYPE}\" ]]; then\n
    \       if [[ -f \"${oldfilePath}\" ]]; then\n            if [[ \"${PRODUCT}\"
    == \"artifactory\" ]]; then\n                productVersion=\"$(readKey \"${property}\"
    \"${oldfilePath}\")\"\n            else\n                productVersion=\"$(cat
    \"${oldfilePath}\")\"\n            fi\n            status=\"success\"\n        elif
    [[ -f \"${newfilePath}\" ]]; then\n            productVersion=\"$(readKey \"${propertyInDocker}\"
    \"${newfilePath}\")\"\n            status=\"fail\"\n        else\n            logger
    \"File [${oldfilePath}] or [${newfilePath}] not found to get current version.\"\n
    \           exit 0\n        fi\n    elif [[ \"$INSTALLER\" == \"${HELM_TYPE}\"
    ]]; then\n        if [[ -f \"${oldfilePath}\" ]]; then\n            if [[ \"${PRODUCT}\"
    == \"artifactory\" ]]; then\n                productVersion=\"$(readKey \"${property}\"
    \"${oldfilePath}\")\"\n            else\n                productVersion=\"$(cat
    \"${oldfilePath}\")\"\n            fi\n            status=\"success\"\n        else\n
    \           productVersion=\"${CURRENT_VERSION}\"\n            [[ -z \"${productVersion}\"
    || \"${productVersion}\" == \"\" ]] && logger \"${PRODUCT} CURRENT_VERSION is
    not set\" && exit 0\n        fi\n    else\n        if [[ -f \"${newfilePath}\"
    ]]; then\n            productVersion=\"$(readKey \"${property}\" \"${newfilePath}\")\"\n
    \           status=\"fail\"\n        elif [[ -f \"${oldfilePath}\" ]]; then\n
    \           productVersion=\"$(readKey \"${property}\" \"${oldfilePath}\")\"\n
    \           status=\"success\"\n        else\n            if [[ \"${INSTALLER}\"
    == \"${ZIP_TYPE}\" ]]; then\n                logger \"File [${newfilePath}] not
    found to get current version.\"\n            else\n                logger \"File
    [${oldfilePath}] or [${newfilePath}] not found to get current version.\"\n            fi\n
    \           exit 0\n        fi\n    fi\n    if [[ -z \"${productVersion}\" ||
    \"${productVersion}\" == \"\" ]]; then\n        [[ \"${status}\" == \"success\"
    ]] && logger \"No version found in file [${oldfilePath}].\"\n        [[ \"${status}\"
    == \"fail\" ]] && logger \"No version found in file [${newfilePath}].\"\n        exit
    0\n    fi\n\n    migrateCheckVersion \"${productVersion}\" \"${minProductVersion}\"
    \"${maxProductVersion}\"\n}\n\nreadKey () {\n    local property=\"$1\"\n    local
    file=\"$2\"\n    local version=\n\n    while IFS='=' read -r key value || [ -n
    \"${key}\" ];\n    do\n        [[ ! \"${key}\" =~ \\#.* && ! -z \"${key}\" &&
    ! -z \"${value}\" ]]\n        key=\"$(io_trim \"${key}\")\"\n        if [[ \"${key}\"
    == \"${property}\" ]]; then\n            version=\"${value}\" && check=true &&
    break\n        else\n            check=false\n        fi\n    done < \"${file}\"\n
    \   if [[ \"${check}\" == \"false\" ]]; then\n        return\n    fi\n    echo
    \"${version}\"\n}\n\n# create Log directory\ncreateLogDir () {\n    if [[ \"${INSTALLER}\"
    == \"${DEB_TYPE}\" || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        getUserAndGroupFromFile\n
    \       removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/log\" \"${USER_TO_CHECK}\"
    \"${GROUP_TO_CHECK}\"\n    fi\n}\n\n# Creating migration log file\ncreationMigrateLog
    () {\n    local LOG_FILE_NAME=\"migration.log\"\n    createLogDir\n    local MIGRATION_LOG_FILE=\"${NEW_DATA_DIR}/log/${LOG_FILE_NAME}\"\n
    \   if [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\"
    ]]; then\n        MIGRATION_LOG_FILE=\"${SCRIPT_HOME}/${LOG_FILE_NAME}\"\n    fi\n
    \   touch \"${MIGRATION_LOG_FILE}\"\n    setFilePermission \"${LOG_FILE_PERMISSION}\"
    \"${MIGRATION_LOG_FILE}\"\n    exec &> >(tee -a \"${MIGRATION_LOG_FILE}\")   \n}\n#
    Set path where system.yaml should create\nsetSystemYamlPath () {\n    SYSTEM_YAML_PATH=\"${NEW_DATA_DIR}/etc/system.yaml\"\n
    \   if [[ \"${INSTALLER}\" != \"${HELM_TYPE}\" ]]; then\n        logger \"system.yaml
    will be created in path [${SYSTEM_YAML_PATH}]\"\n    fi\n}\n# Create directory\ncreateDirectory
    () {\n    local directory=\"$1\"\n    local output=\"$2\"\n    local check=false\n
    \   local message=\"Could not create directory ${directory}, please check if the
    user ${USER} has permissions to perform this action\"\n    removeSoftLink \"${directory}\"\n
    \   mkdir -p \"${directory}\" && check=true || check=false\n    if [[ \"${check}\"
    == \"false\" ]]; then\n        if [[ \"${output}\" == \"Warning\" ]]; then\n            warn
    \"${message}\"\n        else\n            errorExit \"${message}\"\n        fi\n
    \   fi\n    setOwnershipBasedOnInstaller \"${directory}\"\n}\n\nsetOwnershipBasedOnInstaller
    () {\n    local directory=\"$1\"\n    if [[ \"${INSTALLER}\" == \"${DEB_TYPE}\"
    || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        getUserAndGroupFromFile\n
    \       chown -R ${USER_TO_CHECK}:${GROUP_TO_CHECK} \"${directory}\" || warn \"Setting
    ownership on $directory failed\"\n    elif [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\"
    || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        io_setOwnership \"${directory}\"
    \"${JF_USER}\" \"${JF_USER}\"\n    fi\n}\n\ngetUserAndGroup () {\n    local file=\"$1\"\n
    \   read uid gid <<<$(stat -c '%U %G' ${file})\n    USER_TO_CHECK=\"${uid}\"\n
    \   GROUP_TO_CHECK=\"${gid}\"\n}\n    \n# set ownership\ngetUserAndGroupFromFile
    () {\n    case $PRODUCT in\n        artifactory)\n            getUserAndGroup
    \"/etc/opt/jfrog/artifactory/artifactory.properties\"\n        ;;\n        distribution)\n
    \           getUserAndGroup \"${OLD_DATA_DIR}/etc/versions.properties\"\n        ;;\n
    \       xray)\n            getUserAndGroup \"${OLD_DATA_DIR}/security/master.key\"\n
    \       ;;\n        esac\n} \n\n# creating required directories\ncreateRequiredDirs
    () {\n    bannerSubSection \"CREATING REQUIRED DIRECTORIES\"\n    if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\"  ]]; then\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/etc/security\" \"${JF_USER}\" \"${JF_USER}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/data\" \"${JF_USER}\" \"${JF_USER}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/log/archived\" \"${JF_USER}\" \"${JF_USER}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/work\" \"${JF_USER}\" \"${JF_USER}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/backup\" \"${JF_USER}\" \"${JF_USER}\" \"yes\"\n        io_setOwnership
    \"${NEW_DATA_DIR}\" \"${JF_USER}\" \"${JF_USER}\"\n        if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" ]]; then\n            removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/data/postgres\"
    \"${POSTGRES_USER}\" \"${POSTGRES_USER}\" \"yes\"\n        fi\n    elif [[ \"${INSTALLER}\"
    == \"${DEB_TYPE}\" || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        getUserAndGroupFromFile\n
    \       removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/etc\" \"${USER_TO_CHECK}\"
    \"${GROUP_TO_CHECK}\" \"yes\"\n        removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/etc/security\"
    \"${USER_TO_CHECK}\" \"${GROUP_TO_CHECK}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/data\" \"${USER_TO_CHECK}\" \"${GROUP_TO_CHECK}\" \"yes\"\n
    \       removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/log/archived\" \"${USER_TO_CHECK}\"
    \"${GROUP_TO_CHECK}\" \"yes\"\n        removeSoftLinkAndCreateDir \"${NEW_DATA_DIR}/work\"
    \"${USER_TO_CHECK}\" \"${GROUP_TO_CHECK}\" \"yes\"\n        removeSoftLinkAndCreateDir
    \"${NEW_DATA_DIR}/backup\" \"${USER_TO_CHECK}\" \"${GROUP_TO_CHECK}\" \"yes\"\n
    \   fi\n}\n\n# Check entry in map is format\ncheckMapEntry () {\n    local entry=\"$1\"\n\n
    \   [[ \"${entry}\" != *\"=\"* ]] && echo -n \"false\" || echo -n \"true\"\n}\n#
    Check value Empty and warn\nwarnIfEmpty () {\n    local filePath=\"$1\"\n    local
    yamlPath=\"$2\"\n    local check=\n\n    if [[ -z \"${filePath}\" ]]; then\n        warn
    \"Empty value in yamlpath [${yamlPath} in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n
    \       check=false\n    else\n        check=true\n    fi\n    echo \"${check}\"\n}\n\nlogCopyStatus
    () {\n    local status=\"$1\"\n    local logMessage=\"$2\"\n    local warnMessage=\"$3\"\n\n
    \   [[ \"${status}\" == \"success\"  ]] && logger \"${logMessage}\"\n    [[ \"${status}\"
    == \"fail\" ]] && warn \"${warnMessage}\"\n}\n# copy contents from source to destination\ncopyCmd
    () {\n    local source=\"$1\"\n    local target=\"$2\"\n    local mode=\"$3\"\n
    \   local status=\n    \n    case $mode in\n        unique)\n            cp -up
    \"${source}\"/* \"${target}\"/ && status=\"success\" || status=\"fail\"\n            logCopyStatus
    \"${status}\" \"Successfully copied directory contents from [${source}] to [${target}]\"
    \"Failed to copy directory contents from [${source}] to [${target}]\"\n        ;;\n
    \       specific)\n            cp -pf \"${source}\" \"${target}\"/ && status=\"success\"
    || status=\"fail\"\n            logCopyStatus \"${status}\" \"Successfully copied
    file [${source}] to [${target}]\" \"Failed to copy file [${source}] to [${target}]\"\n
    \       ;;\n        patternFiles)\n            cp -pf \"${source}\"* \"${target}\"/
    && status=\"success\" || status=\"fail\"\n            logCopyStatus \"${status}\"
    \"Successfully copied files matching [${source}*] to [${target}]\" \"Failed to
    copy files matching [${source}*] to [${target}]\"\n        ;;\n        full)\n
    \           cp -prf \"${source}\"/* \"${target}\"/ && status=\"success\" || status=\"fail\"\n
    \           logCopyStatus \"${status}\" \"Successfully copied directory contents
    from [${source}] to [${target}]\" \"Failed to copy directory contents from [${source}]
    to [${target}]\"\n        ;;\n    esac\n}\n# Check contents exist in source before
    copying\ncopyOnContentExist () {\n    local source=\"$1\"\n    local target=\"$2\"\n
    \   local mode=\"$3\"\n\n    if [[ \"$(checkContentExists \"${source}\")\" ==
    \"true\" ]]; then\n        copyCmd \"${source}\" \"${target}\" \"${mode}\"\n    else\n
    \       logger \"No contents to copy from [${source}]\"\n    fi\n}\n\n# move source
    to destination\nmoveCmd () {\n    local source=\"$1\"\n    local target=\"$2\"\n
    \   local status=\n    \n    mv -f \"${source}\" \"${target}\" && status=\"success\"
    || status=\"fail\"\n    [[ \"${status}\" == \"success\" ]] && logger \"Successfully
    moved directory [${source}] to [${target}]\"\n    [[ \"${status}\" == \"fail\"
    ]] && warn \"Failed to move directory [${source}] to [${target}]\"\n}\n\n# symlink
    target to source\nsymlinkCmd () {\n    local source=\"$1\"\n    local target=\"$2\"\n
    \   local symlinkSubDir=\"$3\"\n    local check=false\n    \n    if [[ \"${symlinkSubDir}\"
    == \"subDir\" ]]; then\n        ln -sf \"${source}\"/* \"${target}\" && check=true
    || check=false\n    else\n        ln -sf \"${source}\" \"${target}\"   && check=true
    || check=false\n    fi\n    \n    [[ \"${check}\" == \"true\"  ]] && logger \"Successfully
    symlinked directory [${target}] to old [${source}]\"\n    [[ \"${check}\" == \"false\"
    ]] && warn \"Symlink operation failed\"\n}\n# Check contents exist in source before
    symlinking\nsymlinkOnExist () {\n    local source=\"$1\"\n    local target=\"$2\"\n
    \   local symlinkSubDir=\"$3\"\n\n    if [[ \"$(checkContentExists \"${source}\")\"
    == \"true\" ]]; then\n        if [[ \"${symlinkSubDir}\" == \"subDir\" ]]; then\n
    \           symlinkCmd \"${source}\" \"${target}\" \"subDir\"\n        else\n
    \           symlinkCmd \"${source}\" \"${target}\"\n        fi\n    else\n        logger
    \"No contents to symlink from [${source}]\"\n    fi\n}\n\nprependDir () {\n    local
    absolutePath=\"$1\"\n    local fullPath=\"$2\"\n    local sourcePath=\n\n    if
    [[ \"${absolutePath}\" = \\/* ]]; then\n        sourcePath=\"${absolutePath}\"\n
    \   else\n        sourcePath=\"${fullPath}\"\n    fi\n    echo \"${sourcePath}\"\n}\n\ngetFirstEntry
    (){\n    local entry=\"$1\"\n\n    [[ -z \"${entry}\" ]] && return\n    echo \"${entry}\"
    | awk -F\"=\" '{print $1}'\n}\n\ngetSecondEntry () {\n    local entry=\"$1\"\n\n
    \   [[ -z \"${entry}\" ]] && return\n    echo \"${entry}\" | awk -F\"=\" '{print
    $2}'\n}\n# To get absolutePath\npathResolver () {\n    local directoryPath=\"$1\"\n
    \   local dataDir=\n\n    if [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\" ||  \"${INSTALLER}\"
    == \"${HELM_TYPE}\" ]]; then\n        retrieveYamlValue \"migration.oldDataDir\"
    \"oldDataDir\" \"Warning\"\n        dataDir=\"${YAML_VALUE}\"\n        cd \"${dataDir}\"\n
    \   else\n        cd \"${OLD_DATA_DIR}\"\n    fi\n    absoluteDir=\"`cd \"${directoryPath}\";pwd`\"\n
    \   echo \"${absoluteDir}\"\n}\n\ncheckPathResolver () {\n    local value=\"$1\"\n\n
    \   if [[ \"${value}\" == \\/* ]]; then\n        value=\"${value}\"\n    else\n
    \       value=\"$(pathResolver \"${value}\")\"\n    fi\n    echo \"${value}\"\n}\n\npropertyMigrate
    () {\n    local entry=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n
    \   local check=false\n\n    local yamlPath=\"$(getFirstEntry \"${entry}\")\"\n
    \   local property=\"$(getSecondEntry \"${entry}\")\"\n    if [[ -z \"${property}\"
    ]]; then\n        warn \"Property is empty in map [${entry}] in the file [${MIGRATION_SYSTEM_YAML_INFO}]\"\n
    \       return\n    fi\n    if [[ -z \"${yamlPath}\" ]]; then\n        warn \"yamlPath
    is empty for [${property}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n
    \   fi\n    while IFS='=' read -r key value || [ -n \"${key}\" ];\n    do\n        [[
    ! \"${key}\" =~ \\#.* && ! -z \"${key}\" && ! -z \"${value}\" ]]\n        key=\"$(io_trim
    \"${key}\")\"\n        if [[ \"${key}\" == \"${property}\" ]]; then\n            if
    [[ \"${PRODUCT}\" == \"artifactory\" ]]; then\n                value=\"$(migrateResolveDerbyPath
    \"${key}\" \"${value}\")\"\n                value=\"$(migrateResolveHaDirPath
    \"${key}\" \"${value}\")\"\n                value=\"$(updatePostgresUrlString_Hook
    \"${yamlPath}\" \"${value}\")\"\n            fi\n            if [[ \"${key}\"
    == \"context.url\" ]]; then\n                local ip=$(echo \"${value}\" | awk
    -F/ '{print $3}' | sed 's/:.*//')\n                setSystemValue \"shared.node.ip\"
    \"${ip}\" \"${SYSTEM_YAML_PATH}\"\n                logger \"Setting [shared.node.ip]
    with [${ip}] in system.yaml\"\n            fi\n            setSystemValue \"${yamlPath}\"
    \"${value}\" \"${SYSTEM_YAML_PATH}\" && logger \"Setting [${yamlPath}] with value
    of the property [${property}] in system.yaml\" && check=true && break || check=false\n
    \       fi\n    done < \"${NEW_DATA_DIR}/${filePath}/${fileName}\"\n    [[ \"${check}\"
    == \"false\" ]] && logger \"Property [${property}] not found in file [${fileName}]\"\n}\n\nsetHaEnabled_hook
    () {\n    echo \"\"\n}\n\nmigratePropertiesFiles () {\n    local fileList=\n    local
    filePath=\n    local fileName=\n    local map=\n    \n    retrieveYamlValue \"migration.propertyFiles.files\"
    \"fileList\" \"Skip\"\n    fileList=\"${YAML_VALUE}\"\n    if [[ -z \"${fileList}\"
    ]]; then\n        return\n    fi\n    bannerSection \"PROCESSING MIGRATION OF
    PROPERTY FILES\"\n    for file in ${fileList};\n    do\n        bannerSubSection
    \"Processing Migration of $file\"\n        retrieveYamlValue \"migration.propertyFiles.$file.filePath\"
    \"filePath\" \"Warning\"\n        filePath=\"${YAML_VALUE}\"\n        retrieveYamlValue
    \"migration.propertyFiles.$file.fileName\" \"fileName\" \"Warning\"\n        fileName=\"${YAML_VALUE}\"\n
    \       [[ -z \"${filePath}\" && -z \"${fileName}\" ]] && continue\n        if
    [[ \"$(checkFileExists \"${NEW_DATA_DIR}/${filePath}/${fileName}\")\" == \"true\"
    ]]; then\n            logger \"File [${fileName}] found in path [${NEW_DATA_DIR}/${filePath}]\"\n
    \           # setting haEnabled with true only if ha-node.properties is present\n
    \           setHaEnabled_hook \"${filePath}\"\n            retrieveYamlValue \"migration.propertyFiles.$file.map\"
    \"map\" \"Warning\"\n            map=\"${YAML_VALUE}\"\n            [[ -z \"${map}\"
    ]] && continue\n            for entry in $map;\n            do\n                if
    [[ \"$(checkMapEntry \"${entry}\")\" == \"true\" ]]; then\n                    propertyMigrate
    \"${entry}\" \"${filePath}\" \"${fileName}\"\n                else\n                    warn
    \"map entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is not in correct format,
    correct format i.e yamlPath=property\"\n                fi\n            done\n
    \       else\n            logger \"File [${fileName}] was not found in path [${NEW_DATA_DIR}/${filePath}]
    to migrate\"\n        fi\n    done\n}\n\ncreateTargetDir () {\n    local mountDir=\"$1\"\n
    \   local target=\"$2\"\n\n    logger \"Target directory not found [${mountDir}/${target}],
    creating it\"\n    createDirectoryRecursive \"${mountDir}\" \"${target}\" \"Warning\"\n}\n\ncreateDirectoryRecursive
    () {\n    local mountDir=\"$1\"\n    local target=\"$2\"\n    local output=\"$3\"\n
    \   local check=false\n    local message=\"Could not create directory ${directory},
    please check if the user ${USER} has permissions to perform this action\"\n    removeSoftLink
    \"${mountDir}/${target}\"\n    local directory=$(echo \"${target}\" | tr '/' '
    ' )\n    local targetDir=\"${mountDir}\"\n    for dir in ${directory}; \n    do\n
    \       targetDir=\"${targetDir}/${dir}\"\n        mkdir -p \"${targetDir}\" &&
    check=true || check=false\n        setOwnershipBasedOnInstaller \"${targetDir}\"\n
    \   done\n    if [[ \"${check}\" == \"false\" ]]; then\n        if [[ \"${output}\"
    == \"Warning\" ]]; then\n            warn \"${message}\"\n        else\n            errorExit
    \"${message}\"\n        fi\n    fi\n}\n\ncopyOperation () {\n    local source=\"$1\"\n
    \   local target=\"$2\"\n    local mode=\"$3\"\n    local check=false\n    local
    targetDataDir=\n    local targetLink=\n    local date=\n\n    # prepend OLD_DATA_DIR
    only if source is relative path\n    source=\"$(prependDir \"${source}\" \"${OLD_DATA_DIR}/${source}\")\"\n
    \   if [[ \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        targetDataDir=\"${NEW_DATA_DIR}\"\n
    \   else\n        targetDataDir=\"`cd \"${NEW_DATA_DIR}\"/../;pwd`\"\n    fi\n
    \   copyLogMessage \"${mode}\"\n    #remove source if it is a symlink\n    if
    [[ -L \"${source}\" ]]; then\n        targetLink=$(readlink -f \"${source}\")\n
    \       logger \"Removing the symlink [${source}] pointing to [${targetLink}]\"\n
    \       rm -f \"${source}\"\n        source=${targetLink}\n    fi\n    if [[ \"$(checkDirExists
    \"${source}\")\" != \"true\" ]]; then\n        logger \"Source [${source}] directory
    not found in path\"\n        return\n    fi\n    if [[ \"$(checkDirContents \"${source}\")\"
    != \"true\" ]]; then\n        logger \"No contents to copy from [${source}]\"\n
    \       return\n    fi\n    if [[ \"$(checkDirExists \"${targetDataDir}/${target}\")\"
    != \"true\" ]]; then\n        createTargetDir \"${targetDataDir}\" \"${target}\"\n
    \   fi\n    copyOnContentExist \"${source}\" \"${targetDataDir}/${target}\" \"${mode}\"\n}\n\ncopySpecificFiles
    () {\n    local source=\"$1\"\n    local target=\"$2\"\n    local mode=\"$3\"\n
    \   \n    # prepend OLD_DATA_DIR only if source is relative path\n    source=\"$(prependDir
    \"${source}\" \"${OLD_DATA_DIR}/${source}\")\"\n    if [[ \"${INSTALLER}\" ==
    \"${HELM_TYPE}\" ]]; then\n        targetDataDir=\"${NEW_DATA_DIR}\"\n    else\n
    \       targetDataDir=\"`cd \"${NEW_DATA_DIR}\"/../;pwd`\"\n    fi\n    copyLogMessage
    \"${mode}\"\n    if [[ \"$(checkFileExists \"${source}\")\" != \"true\" ]]; then\n
    \       logger \"Source file [${source}] does not exist in path\"\n        return\n
    \   fi\n    if [[ \"$(checkDirExists \"${targetDataDir}/${target}\")\" != \"true\"
    ]]; then\n        createTargetDir \"${targetDataDir}\" \"${target}\"\n    fi\n
    \   copyCmd \"${source}\" \"${targetDataDir}/${target}\" \"${mode}\"\n}\n\ncopyPatternMatchingFiles
    () {\n    local source=\"$1\"\n    local target=\"$2\"\n    local mode=\"$3\"\n
    \   local sourcePath=\"${4}\"\n\n    # prepend OLD_DATA_DIR only if source is
    relative path\n    sourcePath=\"$(prependDir \"${sourcePath}\" \"${OLD_DATA_DIR}/${sourcePath}\")\"\n
    \   if [[ \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        targetDataDir=\"${NEW_DATA_DIR}\"\n
    \   else\n        targetDataDir=\"`cd \"${NEW_DATA_DIR}\"/../;pwd`\"\n    fi\n
    \   copyLogMessage \"${mode}\"\n    if [[ \"$(checkDirExists \"${sourcePath}\")\"
    != \"true\" ]]; then\n        logger \"Source [${sourcePath}] directory not found
    in path\"\n        return\n    fi\n    if ls \"${sourcePath}/${source}\"* 1> /dev/null
    2>&1; then\n        if [[ \"$(checkDirExists \"${targetDataDir}/${target}\")\"
    != \"true\" ]]; then\n            createTargetDir \"${targetDataDir}\" \"${target}\"\n
    \       fi\n        copyCmd \"${sourcePath}/${source}\" \"${targetDataDir}/${target}\"
    \"${mode}\"\n    else\n        logger \"Source file [${sourcePath}/${source}*]
    does not exist in path\"\n    fi\n}\n\ncopyLogMessage () {\n    local mode=\"$1\"\n
    \   case $mode in\n        specific)\n            logger \"Copy file [${source}]
    to target [${targetDataDir}/${target}]\"\n        ;;\n        patternFiles)\n
    \           logger \"Copy files matching [${sourcePath}/${source}*] to target
    [${targetDataDir}/${target}]\"\n        ;;\n        full)\n            logger
    \"Copy directory contents from source [${source}] to target [${targetDataDir}/${target}]\"\n
    \       ;;\n        unique)\n            logger \"Copy directory contents from
    source [${source}] to target [${targetDataDir}/${target}]\"\n        ;;\n    esac\n}\n\ncopyBannerMessages
    () {\n    local mode=\"$1\"\n    local textMode=\"$2\"\n    case $mode in\n        specific)\n
    \           bannerSection \"COPY ${textMode} FILES\"\n        ;;\n        patternFiles)\n
    \           bannerSection \"COPY MATCHING ${textMode}\"\n        ;;\n        full)\n
    \           bannerSection \"COPY ${textMode} DIRECTORIES CONTENTS\"\n        ;;\n
    \       unique)\n            bannerSection \"COPY ${textMode} DIRECTORIES CONTENTS\"\n
    \       ;;\n    esac\n}\n\ninvokeCopyFunctions () {\n    local mode=\"$1\"\n    local
    source=\"$2\"\n    local target=\"$3\"\n\n    case $mode in\n        specific)\n
    \           copySpecificFiles \"${source}\" \"${target}\" \"${mode}\"\n        ;;\n
    \       patternFiles)\n            retrieveYamlValue \"migration.${copyFormat}.sourcePath\"
    \"map\" \"Warning\"\n            local sourcePath=\"${YAML_VALUE}\"\n            copyPatternMatchingFiles
    \"${source}\" \"${target}\" \"${mode}\" \"${sourcePath}\"\n        ;;\n        full)\n
    \           copyOperation \"${source}\" \"${target}\" \"${mode}\"\n        ;;\n
    \       unique)\n            copyOperation \"${source}\" \"${target}\" \"${mode}\"\n
    \       ;;\n    esac\n}\n# Copies contents from source directory and target directory\ncopyDataDirectories
    () {\n    local copyFormat=\"$1\"\n    local mode=\"$2\"\n    local map=\n    local
    source=\n    local target=\n    local textMode=\n    local targetDataDir=\n    local
    copyFormatValue=\n\n    retrieveYamlValue \"migration.${copyFormat}\" \"${copyFormat}\"
    \"Skip\"\n    copyFormatValue=\"${YAML_VALUE}\"\n    if [[ -z \"${copyFormatValue}\"
    ]]; then\n        return\n    fi\n    textMode=$(echo \"${mode}\" | tr '[:lower:]'
    '[:upper:]' 2>/dev/null)\n    copyBannerMessages \"${mode}\" \"${textMode}\"\n
    \   retrieveYamlValue \"migration.${copyFormat}.map\" \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n
    \   if [[ \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        targetDataDir=\"${NEW_DATA_DIR}\"\n
    \   else\n        targetDataDir=\"`cd \"${NEW_DATA_DIR}\"/../;pwd`\"\n    fi\n
    \   for entry in $map;\n    do\n        if [[ \"$(checkMapEntry \"${entry}\")\"
    == \"true\" ]]; then\n            source=\"$(getSecondEntry \"${entry}\")\"\n
    \           target=\"$(getFirstEntry \"${entry}\")\"\n            [[ -z \"${source}\"
    ]] && warn \"source value is empty for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"
    && continue\n            [[ -z \"${target}\" ]] && warn \"target value is empty
    for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\" && continue\n            invokeCopyFunctions
    \"${mode}\" \"${source}\" \"${target}\"\n        else\n            warn \"map
    entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is not in correct format,
    correct format i.e target=source\"\n        fi\n        echo \"\";\n    done\n}\n\ninvokeMoveFunctions
    () {\n    local source=\"$1\"\n    local target=\"$2\"\n    local sourceDataDir=\n
    \   local targetBasename=\n    # prepend OLD_DATA_DIR only if source is relative
    path\n    sourceDataDir=$(prependDir \"${source}\" \"${OLD_DATA_DIR}/${source}\")\n
    \   targetBasename=$(dirname \"${target}\")\n    logger \"Moving directory source
    [${sourceDataDir}] to target [${NEW_DATA_DIR}/${target}]\"\n    if [[ \"$(checkDirExists
    \"${sourceDataDir}\")\" != \"true\" ]]; then\n        logger \"Directory [${sourceDataDir}]
    not found in path to move\"\n        return\n    fi\n    if [[ \"$(checkDirExists
    \"${NEW_DATA_DIR}/${targetBasename}\")\" != \"true\" ]]; then\n        createTargetDir
    \"${NEW_DATA_DIR}\" \"${targetBasename}\"\n        moveCmd \"${sourceDataDir}\"
    \"${NEW_DATA_DIR}/${target}\"\n    else\n        moveCmd \"${sourceDataDir}\"
    \"${NEW_DATA_DIR}/tempDir\"\n        moveCmd \"${NEW_DATA_DIR}/tempDir\" \"${NEW_DATA_DIR}/${target}\"\n
    \   fi\n}\n\n# Move source directory and target directory\nmoveDirectories ()
    {\n    local moveDataDirectories=\n    local map=\n    local source=\n    local
    target=\n\n    retrieveYamlValue \"migration.moveDirectories\" \"moveDirectories\"
    \"Skip\"\n    moveDirectories=\"${YAML_VALUE}\"\n    if [[ -z \"${moveDirectories}\"
    ]]; then\n        return\n    fi\n    bannerSection \"MOVE DIRECTORIES\"\n    retrieveYamlValue
    \"migration.moveDirectories.map\" \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n
    \   for entry in $map;\n    do\n        if [[ \"$(checkMapEntry \"${entry}\")\"
    == \"true\" ]]; then\n            source=\"$(getSecondEntry \"${entry}\")\"\n
    \           target=\"$(getFirstEntry \"${entry}\")\"\n            [[ -z \"${source}\"
    ]] && warn \"source value is empty for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"
    && continue\n            [[ -z \"${target}\" ]] && warn \"target value is empty
    for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\" && continue\n            invokeMoveFunctions
    \"${source}\" \"${target}\"\n        else\n            warn \"map entry [${entry}]
    in [${MIGRATION_SYSTEM_YAML_INFO}] is not in correct format, correct format i.e
    target=source\"\n        fi\n    echo \"\";\n    done\n}\n\n# Trim masterKey if
    its generated using hex 32 \ntrimMasterKey () {\n    local masterKeyDir=/opt/jfrog/artifactory/var/etc/security\n
    \   local oldMasterKey=$(<${masterKeyDir}/master.key)\n    local oldMasterKey_Length=$(echo
    ${#oldMasterKey})\n    local newMasterKey=\n    if [[ ${oldMasterKey_Length} -gt
    32 ]]; then\n        bannerSection \"TRIM MASTERKEY\"\n        newMasterKey=$(echo
    ${oldMasterKey:0:32})\n        cp ${masterKeyDir}/master.key ${masterKeyDir}/backup_master.key\n
    \       logger \"Original masterKey is backed up : ${masterKeyDir}/backup_master.key\"\n
    \       rm -rf ${masterKeyDir}/master.key\n        echo ${newMasterKey} > ${masterKeyDir}/master.key\n
    \       logger \"masterKey is trimmed : ${masterKeyDir}/master.key\"\n    fi\n}\n\ncopyDirectories
    () {\n\n    copyDataDirectories \"copyFiles\" \"full\"\n    copyDataDirectories
    \"copyUniqueFiles\" \"unique\"\n    copyDataDirectories \"copySpecificFiles\"
    \"specific\"\n    copyDataDirectories \"copyPatternMatchingFiles\" \"patternFiles\"\n}\n\nsymlinkDir
    () {\n    local source=\"$1\"\n    local target=\"$2\"\n    local targetDir=\n
    \   local basename=\n    local targetParentDir=\n    \n    targetDir=\"$(dirname
    \"${target}\")\"\n    if [[ \"${targetDir}\" == \"${source}\" ]]; then\n        #
    symlink the sub directories\n        createDirectory \"${NEW_DATA_DIR}/${target}\"
    \"Warning\"\n        if [[ \"$(checkDirExists \"${NEW_DATA_DIR}/${target}\")\"
    == \"true\" ]]; then\n            symlinkOnExist \"${OLD_DATA_DIR}/${source}\"
    \"${NEW_DATA_DIR}/${target}\" \"subDir\"\n            basename=\"$(basename \"${target}\")\"\n
    \           cd \"${NEW_DATA_DIR}/${target}\" && rm -f \"${basename}\"\n        fi\n
    \   else\n        targetParentDir=\"$(dirname \"${NEW_DATA_DIR}/${target}\")\"\n
    \       createDirectory \"${targetParentDir}\" \"Warning\"\n        if [[ \"$(checkDirExists
    \"${targetParentDir}\")\" == \"true\" ]]; then\n            symlinkOnExist \"${OLD_DATA_DIR}/${source}\"
    \"${NEW_DATA_DIR}/${target}\"\n        fi\n    fi\n}\n\nsymlinkOperation () {\n
    \   local source=\"$1\"\n    local target=\"$2\"\n    local check=false\n    local
    targetLink=\n    local date=\n    \n    #   Check if source is a link and do symlink\n
    \   if [[ -L \"${OLD_DATA_DIR}/${source}\" ]]; then\n        targetLink=$(readlink
    -f \"${OLD_DATA_DIR}/${source}\")\n        symlinkOnExist \"${targetLink}\" \"${NEW_DATA_DIR}/${target}\"\n
    \   else\n        #  check if source is directory and do symlink\n        if [[
    \"$(checkDirExists \"${OLD_DATA_DIR}/${source}\")\" != \"true\" ]]; then\n            logger
    \"Source [${source}] directory not found in path to symlink\"\n            return\n
    \       fi\n        if [[ \"$(checkDirContents \"${OLD_DATA_DIR}/${source}\")\"
    != \"true\" ]]; then\n            logger \"No contents found in [${OLD_DATA_DIR}/${source}]
    to symlink\"\n            return\n        fi\n        if [[ \"$(checkDirExists
    \"${NEW_DATA_DIR}/${target}\")\" != \"true\" ]]; then\n            logger \"Target
    directory [${NEW_DATA_DIR}/${target}] does not exist to create symlink, creating
    it\"\n            symlinkDir \"${source}\" \"${target}\"\n        else\n            rm
    -rf \"${NEW_DATA_DIR}/${target}\" && check=true || check=false\n            [[
    \"${check}\" == \"false\" ]] && warn \"Failed to remove contents in [${NEW_DATA_DIR}/${target}/]\"\n
    \           symlinkDir \"${source}\" \"${target}\"\n        fi\n    fi\n}\n# Creates
    a symlink path - Source directory to which the symbolic link should point.\nsymlinkDirectories
    () {\n    local linkFiles=\n    local map=\n    local source=\n    local target=\n\n
    \   retrieveYamlValue \"migration.linkFiles\" \"linkFiles\" \"Skip\"\n    linkFiles=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${linkFiles}\" ]]; then\n        return\n    fi\n    bannerSection
    \"SYMLINK DIRECTORIES\"\n    retrieveYamlValue \"migration.linkFiles.map\" \"map\"
    \"Warning\"\n    map=\"${YAML_VALUE}\"\n    for entry in $map;\n    do\n        if
    [[ \"$(checkMapEntry \"${entry}\")\" == \"true\" ]]; then\n            source=\"$(getSecondEntry
    \"${entry}\")\"\n            target=\"$(getFirstEntry \"${entry}\")\"\n            logger
    \"Symlink directory [${NEW_DATA_DIR}/${target}] to old [${OLD_DATA_DIR}/${source}]\"\n
    \           [[ -z \"${source}\" ]] && warn \"source value is empty for [${entry}]
    in [${MIGRATION_SYSTEM_YAML_INFO}]\" && continue\n            [[ -z \"${target}\"
    ]] && warn \"target value is empty for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"
    && continue\n            symlinkOperation \"${source}\" \"${target}\"\n        else\n
    \           warn \"map entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is
    not in correct format, correct format i.e target=source\"\n        fi\n        echo
    \"\";\n    done\n}\n\nupdateConnectionString () {\n    local yamlPath=\"$1\"\n
    \   local value=\"$2\"\n    local mongoPath=\"shared.mongo.url\"\n    local rabbitmqPath=\"shared.rabbitMq.url\"\n
    \   local postgresPath=\"shared.database.url\"\n    local redisPath=\"shared.redis.connectionString\"\n
    \   local mongoConnectionString=\"mongo.connectionString\"\n    local sourceKey=\n
    \   local hostIp=$(io_getPublicHostIP)\n    local hostKey=\n    \n    if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then \n    #
    Replace @postgres:,@mongodb:,@rabbitmq:,@redis: to @{hostIp}: (Compose Installer)\n
    \       hostKey=\"@${hostIp}:\"\n        case $yamlPath in\n            ${postgresPath})\n
    \               sourceKey=\"@postgres:\"\n                value=$(io_replaceString
    \"${value}\" \"${sourceKey}\" \"${hostKey}\")\n            ;;\n            ${mongoPath})\n
    \               sourceKey=\"@mongodb:\"\n                value=$(io_replaceString
    \"${value}\" \"${sourceKey}\" \"${hostKey}\")\n            ;;\n            ${rabbitmqPath})\n
    \               sourceKey=\"@rabbitmq:\"\n                value=$(io_replaceString
    \"${value}\" \"${sourceKey}\" \"${hostKey}\")\n            ;;\n            ${redisPath})\n
    \               sourceKey=\"@redis:\"\n                value=$(io_replaceString
    \"${value}\" \"${sourceKey}\" \"${hostKey}\")\n            ;;\n            ${mongoConnectionString})\n
    \               sourceKey=\"@mongodb:\"\n                value=$(io_replaceString
    \"${value}\" \"${sourceKey}\" \"${hostKey}\")\n            ;;\n        esac\n
    \   fi\n    echo -n \"${value}\"\n}\n\nyamlMigrate () {\n    local entry=\"$1\"\n
    \   local sourceFile=\"$2\"\n    local value=\n    local yamlPath=\n    local
    key=\n    yamlPath=\"$(getFirstEntry \"${entry}\")\"\n    key=\"$(getSecondEntry
    \"${entry}\")\"\n    if [[ -z \"${key}\" ]]; then\n        warn \"key is empty
    in map [${entry}] in the file [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n
    \   fi\n    if [[ -z \"${yamlPath}\" ]]; then\n        warn \"yamlPath is empty
    for [${key}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n    fi\n    getYamlValue
    \"${key}\" \"${sourceFile}\" \"false\"\n    value=\"${YAML_VALUE}\"\n    if [[
    ! -z \"${value}\" ]]; then\n        value=$(updateConnectionString \"${yamlPath}\"
    \"${value}\")\n    fi\n    if [[ \"${PRODUCT}\" == \"artifactory\" ]]; then\n
    \       replicatorProfiling\n    fi\n    if [[ -z \"${value}\" ]]; then\n        logger
    \"No value for [${key}] in [${sourceFile}]\"\n    else\n        setSystemValue
    \"${yamlPath}\" \"${value}\" \"${SYSTEM_YAML_PATH}\"\n        logger \"Setting
    [${yamlPath}] with value of the key [${key}] in system.yaml\"\n    fi\n}\n\nmigrateYamlFile
    () {\n    local files=\n    local filePath=\n    local fileName=\n    local sourceFile=\n
    \   local map=\n    retrieveYamlValue \"migration.yaml.files\" \"files\" \"Skip\"\n
    \   files=\"${YAML_VALUE}\"\n    if [[ -z \"${files}\" ]]; then\n        return\n
    \   fi\n    bannerSection \"MIGRATION OF YAML FILES\"\n    for file in $files;\n
    \   do\n        bannerSubSection \"Processing Migration of $file\"\n        retrieveYamlValue
    \"migration.yaml.$file.filePath\" \"filePath\" \"Warning\"\n        filePath=\"${YAML_VALUE}\"\n
    \       retrieveYamlValue \"migration.yaml.$file.fileName\" \"fileName\" \"Warning\"\n
    \       fileName=\"${YAML_VALUE}\"\n        [[ -z \"${filePath}\" && -z \"${fileName}\"
    ]] && continue\n        sourceFile=\"${NEW_DATA_DIR}/${filePath}/${fileName}\"\n
    \       if [[ \"$(checkFileExists \"${sourceFile}\")\" == \"true\" ]]; then\n
    \           logger \"File [${fileName}] found in path [${NEW_DATA_DIR}/${filePath}]\"\n
    \           retrieveYamlValue \"migration.yaml.$file.map\" \"map\" \"Warning\"\n
    \           map=\"${YAML_VALUE}\"\n            [[ -z \"${map}\" ]] && continue\n
    \           for entry in $map;\n            do\n                if [[ \"$(checkMapEntry
    \"${entry}\")\" == \"true\" ]]; then\n                    yamlMigrate \"${entry}\"
    \"${sourceFile}\"\n                else\n                    warn \"map entry
    [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is not in correct format, correct
    format i.e yamlPath=key\"\n                fi\n            done\n        else\n
    \           logger \"File [${fileName}] is not found in path [${NEW_DATA_DIR}/${filePath}]
    to migrate\"\n        fi\n    done\n}\n# updates the key and value in system.yaml\nupdateYamlKeyValue
    () {\n    local entry=\"$1\"\n    local value=\n    local yamlPath=\n    local
    key=\n\n    yamlPath=\"$(getFirstEntry \"${entry}\")\"\n    value=\"$(getSecondEntry
    \"${entry}\")\"\n    if [[ -z \"${value}\" ]]; then\n        warn \"value is empty
    in map [${entry}] in the file [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n
    \   fi\n    if [[ -z \"${yamlPath}\" ]]; then\n        warn \"yamlPath is empty
    for [${key}] in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n    fi\n    setSystemValue
    \"${yamlPath}\" \"${value}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${yamlPath}]
    with value [${value}] in system.yaml\"\n}\n\nupdateSystemYamlFile () {\n    local
    updateYaml=\n    local map=\n\n    retrieveYamlValue \"migration.updateSystemYaml\"
    \"updateYaml\" \"Skip\"\n    updateSystemYaml=\"${YAML_VALUE}\"\n    if [[ -z
    \"${updateSystemYaml}\" ]]; then\n        return\n    fi\n    bannerSection \"UPDATE
    SYSTEM YAML FILE WITH KEY AND VALUES\"\n    retrieveYamlValue \"migration.updateSystemYaml.map\"
    \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n    if [[ -z \"${map}\" ]]; then\n
    \       return\n    fi\n    for entry in $map;\n    do\n        if [[ \"$(checkMapEntry
    \"${entry}\")\" == \"true\" ]]; then\n            updateYamlKeyValue \"${entry}\"\n
    \       else\n            warn \"map entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]
    is not in correct format, correct format i.e yamlPath=key\"\n        fi\n    done\n}\n\nbackupFiles_hook
    () {\n    logSilly \"Method ${FUNCNAME[0]}\"\n}\n\nbackupDirectory () {\n    local
    backupDir=\"$1\"\n    local dir=\"$2\"\n    local targetDir=\"$3\"\n    local
    effectiveUser=\n    local effectiveGroup=\n\n    if [[ \"${dir}\" = \\/* ]]; then\n
    \       dir=$(echo \"${dir/\\//}\")\n    fi\n            \n    if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then \n        effectiveUser=\"${JF_USER}\"\n
    \       effectiveGroup=\"${JF_USER}\"\n    elif [[ \"${INSTALLER}\" == \"${DEB_TYPE}\"
    || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        effectiveUser=\"${USER_TO_CHECK}\"
    \n        effectiveGroup=\"${GROUP_TO_CHECK}\"\n    fi\n    \n    removeSoftLinkAndCreateDir
    \"${backupDir}\" \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n    local
    backupDirectory=\"${backupDir}/${PRODUCT}\"\n    removeSoftLinkAndCreateDir \"${backupDirectory}\"
    \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n    removeSoftLinkAndCreateDir
    \"${backupDirectory}/${dir}\" \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n
    \   local outputCheckDirExists=\"$(checkDirExists \"${backupDirectory}/${dir}\")\"\n
    \   if [[ \"${outputCheckDirExists}\" == \"true\" ]]; then\n        copyOnContentExist
    \"${targetDir}\" \"${backupDirectory}/${dir}\" \"full\"\n    fi\n}\n\nremoveOldDirectory
    () {\n    local backupDir=\"$1\"\n    local entry=\"$2\"\n    local check=false\n
    \   \n    # prepend OLD_DATA_DIR only if entry is relative path\n    local targetDir=\"$(prependDir
    \"${entry}\" \"${OLD_DATA_DIR}/${entry}\")\"\n    local outputCheckDirExists=\"$(checkDirExists
    \"${targetDir}\")\"\n    if [[ \"${outputCheckDirExists}\" != \"true\" ]]; then\n
    \       logger \"No [${targetDir}] directory found to delete\"\n        echo \"\";\n
    \       return\n    fi\n    backupDirectory \"${backupDir}\" \"${entry}\" \"${targetDir}\"\n
    \   rm -rf  \"${targetDir}\" && check=true || check=false\n    [[ \"${check}\"
    == \"true\"  ]] && logger \"Successfully removed directory [${targetDir}]\"\n
    \   [[ \"${check}\" == \"false\" ]] && warn \"Failed to remove directory [${targetDir}]\"\n
    \   echo \"\";\n}\n\ncleanUpOldDataDirectories () {\n    local cleanUpOldDataDir=\n
    \   local map=\n    local entry=\n\n    retrieveYamlValue \"migration.cleanUpOldDataDir\"
    \"cleanUpOldDataDir\" \"Skip\"\n    cleanUpOldDataDir=\"${YAML_VALUE}\"\n    if
    [[ -z \"${cleanUpOldDataDir}\" ]]; then\n        return\n    fi\n    bannerSection
    \"CLEAN UP OLD DATA DIRECTORIES\"\n    retrieveYamlValue \"migration.cleanUpOldDataDir.map\"
    \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n    [[ -z \"${map}\" ]] && continue\n
    \   date=\"$(date +%Y%m%d%H%M)\"\n    backupDir=\"${NEW_DATA_DIR}/backup/backup-${date}\"\n
    \   bannerImportant \"****** Old data configurations are backedup in [${backupDir}]
    directory ******\"\n    backupFiles_hook \"${backupDir}/${PRODUCT}\"\n    for
    entry in $map;\n    do\n        removeOldDirectory \"${backupDir}\" \"${entry}\"\n
    \   done\n}\n\nbackupFiles () {\n    local backupDir=\"$1\"\n    local dir=\"$2\"\n
    \   local targetDir=\"$3\"\n    local fileName=\"$4\"\n    local effectiveUser=\n
    \   local effectiveGroup=\n\n    if [[ \"${dir}\" = \\/* ]]; then\n        dir=$(echo
    \"${dir/\\//}\")\n    fi\n            \n    if [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\"
    || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then \n        effectiveUser=\"${JF_USER}\"\n
    \       effectiveGroup=\"${JF_USER}\"\n    elif [[ \"${INSTALLER}\" == \"${DEB_TYPE}\"
    || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        effectiveUser=\"${USER_TO_CHECK}\"
    \n        effectiveGroup=\"${GROUP_TO_CHECK}\"\n    fi\n\n    removeSoftLinkAndCreateDir
    \"${backupDir}\" \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n    local
    backupDirectory=\"${backupDir}/${PRODUCT}\"\n    removeSoftLinkAndCreateDir \"${backupDirectory}\"
    \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n    removeSoftLinkAndCreateDir
    \"${backupDirectory}/${dir}\" \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n
    \   local outputCheckDirExists=\"$(checkDirExists \"${backupDirectory}/${dir}\")\"\n
    \   if [[ \"${outputCheckDirExists}\" == \"true\" ]]; then\n        copyCmd \"${targetDir}/${fileName}\"
    \"${backupDirectory}/${dir}\" \"specific\"\n    fi\n}\n\nremoveOldFiles () {\n
    \   local backupDir=\"$1\"\n    local directoryName=\"$2\"\n    local fileName=\"$3\"\n
    \   local check=false\n    \n    # prepend OLD_DATA_DIR only if entry is relative
    path\n    local targetDir=\"$(prependDir \"${directoryName}\" \"${OLD_DATA_DIR}/${directoryName}\")\"\n
    \   local outputCheckFileExists=\"$(checkFileExists \"${targetDir}/${fileName}\")\"\n
    \   if [[ \"${outputCheckFileExists}\" != \"true\" ]]; then\n        logger \"No
    [${targetDir}/${fileName}] file found to delete\"\n        return\n    fi\n    backupFiles
    \"${backupDir}\" \"${directoryName}\" \"${targetDir}\" \"${fileName}\"\n    rm
    -f  \"${targetDir}/${fileName}\" && check=true || check=false\n    [[ \"${check}\"
    == \"true\"  ]] && logger \"Successfully removed file [${targetDir}/${fileName}]\"\n
    \   [[ \"${check}\" == \"false\" ]] && warn \"Failed to remove file [${targetDir}/${fileName}]\"\n
    \   echo \"\";\n}\n\ncleanUpOldFiles () {\n    local cleanUpFiles=\n    local
    map=\n    local entry=\n\n    retrieveYamlValue \"migration.cleanUpOldFiles\"
    \"cleanUpOldFiles\" \"Skip\"\n    cleanUpOldFiles=\"${YAML_VALUE}\"\n    if [[
    -z \"${cleanUpOldFiles}\" ]]; then\n        return\n    fi\n    bannerSection
    \"CLEAN UP OLD FILES\"\n    retrieveYamlValue \"migration.cleanUpOldFiles.map\"
    \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n    [[ -z \"${map}\" ]] && continue\n
    \   date=\"$(date +%Y%m%d%H%M)\"\n    backupDir=\"${NEW_DATA_DIR}/backup/backup-${date}\"\n
    \   bannerImportant \"****** Old files are backedup in [${backupDir}] directory
    ******\"\n    for entry in $map;\n    do  \n        local outputCheckMapEntry=\"$(checkMapEntry
    \"${entry}\")\"\n        if [[ \"${outputCheckMapEntry}\" != \"true\" ]]; then\n
    \           warn \"map entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is
    not in correct format, correct format i.e directoryName=fileName\"\n        fi\n
    \       local fileName=\"$(getSecondEntry \"${entry}\")\"\n        local directoryName=\"$(getFirstEntry
    \"${entry}\")\"\n        [[ -z \"${fileName}\" ]] && warn \"File name value is
    empty for [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}]\" && continue\n        [[
    -z \"${directoryName}\" ]] && warn \"Directory name value is empty for [${entry}]
    in [${MIGRATION_SYSTEM_YAML_INFO}]\" && continue\n        removeOldFiles \"${backupDir}\"
    \"${directoryName}\" \"${fileName}\"\n        echo \"\";\n    done \n}\n\nstartMigration
    () {\n    bannerSection \"STARTING MIGRATION\"\n}\n\nendMigration () {\n    bannerSection
    \"MIGRATION COMPLETED SUCCESSFULLY\"\n}\n\ninitialize () {\n    setAppDir\n    _pauseExecution
    \"setAppDir\"\n    initHelpers\n    _pauseExecution \"initHelpers\"\n    checkMigrationInfoYaml\n
    \   _pauseExecution \"checkMigrationInfoYaml\"\n    getProduct\n    _pauseExecution
    \"getProduct\"\n    getDataDir\n    _pauseExecution \"getDataDir\"\n}\n\nmain
    () {\n    case $PRODUCT in\n        artifactory)\n            migrateArtifactory\n
    \       ;;\n        distribution)\n            migrateDistribution\n        ;;\n
    \       xray)\n            migrationXray\n        ;;\n    esac\n    exit 0\n}\n\n#
    Ensures meta data is logged\nLOG_BEHAVIOR_ADD_META=\"$FLAG_Y\"\n\n\nmigrateResolveDerbyPath
    () {\n    local key=\"$1\"\n    local value=\"$2\"\n\n    if [[ \"${key}\" ==
    \"url\" && \"${value}\" == *\"db.home\"* ]]; then\n        if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" ]]; then\n            derbyPath=\"/opt/jfrog/artifactory/var/data/artifactory/derby\"\n
    \           value=$(echo \"${value}\" | sed \"s|{db.home}|$derbyPath|\")\n        else\n
    \           derbyPath=\"${NEW_DATA_DIR}/data/artifactory/derby\"\n            value=$(echo
    \"${value}\" | sed \"s|{db.home}|$derbyPath|\")\n        fi\n    fi\n    echo
    \"${value}\"\n}\n\nmigrateResolveHaDirPath () {\n    local key=\"$1\"\n    local
    value=\"$2\"\n\n    if [[ \"${INSTALLER}\" == \"${RPM_TYPE}\" || \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\" || \"${INSTALLER}\"
    == \"${DEB_TYPE}\" ]]; then\n        if [[ \"${key}\" == \"artifactory.ha.data.dir\"
    || \"${key}\" == \"artifactory.ha.backup.dir\" ]]; then\n            value=$(checkPathResolver
    \"${value}\")\n        fi\n    fi\n    echo \"${value}\"\n}\nupdatePostgresUrlString_Hook
    () {\n    local yamlPath=\"$1\"\n    local value=\"$2\"\n    local hostIp=$(io_getPublicHostIP)\n
    \   local sourceKey=\"//postgresql:\"\n    if [[ \"${yamlPath}\" == \"shared.database.url\"
    ]]; then\n        value=$(io_replaceString \"${value}\" \"${sourceKey}\" \"//${hostIp}:\"
    \"#\")\n    fi\n    echo \"${value}\"\n}\n# Check Artifactory product version\ncheckArtifactoryVersion
    () {\n    local minProductVersion=\"6.0.0\"\n    local maxProductVersion=\"7.0.0\"\n
    \   local propertyInDocker=\"ARTIFACTORY_VERSION\"\n    local property=\"artifactory.version\"\n
    \   \n    if [[ \"${INSTALLER}\" ==  \"${COMPOSE_TYPE}\" ]]; then\n        local
    newfilePath=\"${APP_DIR}/../.env\"\n        local oldfilePath=\"${OLD_DATA_DIR}/etc/artifactory.properties\"\n
    \   elif [[ \"${INSTALLER}\" ==  \"${HELM_TYPE}\" ]]; then\n        local oldfilePath=\"${OLD_DATA_DIR}/etc/artifactory.properties\"\n
    \   elif [[ \"${INSTALLER}\" ==  \"${ZIP_TYPE}\" ]]; then\n        local newfilePath=\"${NEW_DATA_DIR}/etc/artifactory/artifactory.properties\"\n
    \       local oldfilePath=\"${OLD_DATA_DIR}/etc/artifactory.properties\"\n    else\n
    \       local newfilePath=\"${NEW_DATA_DIR}/etc/artifactory/artifactory.properties\"\n
    \       local oldfilePath=\"/etc/opt/jfrog/artifactory/artifactory.properties\"\n
    \   fi\n\n    getProductVersion \"${minProductVersion}\" \"${maxProductVersion}\"
    \"${newfilePath}\" \"${oldfilePath}\" \"${propertyInDocker}\" \"${property}\"\n}\n\ngetCustomDataDir_hook
    () {\n    retrieveYamlValue \"migration.oldDataDir\" \"oldDataDir\" \"Fail\"\n
    \   OLD_DATA_DIR=\"${YAML_VALUE}\"\n}\n\n# Get protocol value of connector\ngetXmlConnectorProtocol
    () {\n    local i=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n
    \   local protocolValue=$($LIBXML2_PATH --xpath '//Server/Service/Connector['$i']/@protocol'
    ${filePath}/${fileName} 2>/dev/null |awk -F\"=\" '{print $2}' | tr -d '\"')\n
    \   echo -e \"${protocolValue}\"\n}\n\n# Get all attributes of connector\ngetXmlConnectorAttributes
    () {\n    local i=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n
    \   local connectorAttributes=$($LIBXML2_PATH --xpath '//Server/Service/Connector['$i']/@*'
    ${filePath}/${fileName} 2>/dev/null)\n    # strip leading and trailing spaces\n
    \   connectorAttributes=$(io_trim \"${connectorAttributes}\")\n    echo \"${connectorAttributes}\"\n}\n\n#
    Get port value of connector\ngetXmlConnectorPort () {\n    local i=\"$1\"\n    local
    filePath=\"$2\"\n    local fileName=\"$3\"\n    local portValue=$($LIBXML2_PATH
    --xpath '//Server/Service/Connector['$i']/@port' ${filePath}/${fileName} 2>/dev/null
    | awk -F\"=\" '{print $2}' | tr -d '\"')\n    echo -e \"${portValue}\"\n}\n\n#
    Get maxThreads value of connector\ngetXmlConnectorMaxThreads () {\n    local i=\"$1\"\n
    \   local filePath=\"$2\"\n    local fileName=\"$3\"\n    local maxThreadValue=$($LIBXML2_PATH
    --xpath '//Server/Service/Connector['$i']/@maxThreads' ${filePath}/${fileName}
    2>/dev/null | awk -F\"=\" '{print $2}' | tr -d '\"')\n    echo -e \"${maxThreadValue}\"\n}\n#
    Get sendReasonPhrase value of connector\ngetXmlConnectorSendReasonPhrase () {\n
    \   local i=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n    local
    sendReasonPhraseValue=$($LIBXML2_PATH --xpath '//Server/Service/Connector['$i']/@sendReasonPhrase'
    ${filePath}/${fileName} 2>/dev/null | awk -F\"=\" '{print $2}' | tr -d '\"')\n
    \   echo -e \"${sendReasonPhraseValue}\"\n}\n# Get relaxedPathChars value of connector\ngetXmlConnectorRelaxedPathChars
    () {\n    local i=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n
    \   local relaxedPathCharsValue=$($LIBXML2_PATH --xpath '//Server/Service/Connector['$i']/@relaxedPathChars'
    ${filePath}/${fileName} 2>/dev/null | awk -F\"=\" '{print $2}' | tr -d '\"')\n
    \   # strip leading and trailing spaces\n    relaxedPathCharsValue=$(io_trim \"${relaxedPathCharsValue}\")\n
    \   echo -e \"${relaxedPathCharsValue}\"\n}\n# Get relaxedQueryChars value of
    connector\ngetXmlConnectorRelaxedQueryChars () {\n    local i=\"$1\"\n    local
    filePath=\"$2\"\n    local fileName=\"$3\"\n    local relaxedQueryCharsValue=$($LIBXML2_PATH
    --xpath '//Server/Service/Connector['$i']/@relaxedQueryChars' ${filePath}/${fileName}
    2>/dev/null | awk -F\"=\" '{print $2}' | tr -d '\"')\n    # strip leading and
    trailing spaces\n    relaxedQueryCharsValue=$(io_trim \"${relaxedQueryCharsValue}\")\n
    \   echo -e \"${relaxedQueryCharsValue}\"\n}\n\n# Updating system.yaml with Connector
    port \nsetConnectorPort () {\n    local yamlPath=\"$1\"\n    local valuePort=\"$2\"\n
    \   local portYamlPath=\n    if [[ -z \"${yamlPath}\" ]]; then\n        return\n
    \   fi\n    if [[ -z \"${valuePort}\" ]]; then\n        warn \"port value is empty,
    could not migrate to system.yaml\"\n        return\n    fi\n    ## Getting port
    yaml path from migration info yaml\n    retrieveYamlValue \"${yamlPath}\" portYamlPath
    \"Warning\"\n    portYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${portYamlPath}\"
    ]]; then\n        return\n    fi\n    setSystemValue \"${portYamlPath}\" \"${valuePort}\"
    \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${portYamlPath}] with value [${valuePort}]
    in system.yaml\"\n}\n\n# Updating system.yaml with Connector maxThreads\nsetConnectorMaxThread
    () {\n    local yamlPath=\"$1\"\n    local threadValue=\"$2\"\n    local maxThreadYamlPath=\n
    \   if [[ -z \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z  \"${threadValue}\"
    ]]; then\n        return\n    fi\n    ## Getting max Threads yaml path from migration
    info yaml\n    retrieveYamlValue \"${yamlPath}\" maxThreadYamlPath \"Warning\"\n
    \   maxThreadYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${maxThreadYamlPath}\"
    ]]; then\n        return\n    fi\n    setSystemValue \"${maxThreadYamlPath}\"
    \"${threadValue}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${maxThreadYamlPath}]
    with value [${threadValue}] in system.yaml\"\n}\n\n# Updating system.yaml with
    Connector sendReasonPhrase\nsetConnectorSendReasonPhrase () {\n    local yamlPath=\"$1\"\n
    \   local sendReasonPhraseValue=\"$2\"\n    local sendReasonPhraseYamlPath=\n
    \   if [[ -z \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z  \"${sendReasonPhraseValue}\"
    ]]; then\n        return\n    fi\n    ## Getting sendReasonPhrase yaml path from
    migration info yaml\n    retrieveYamlValue \"${yamlPath}\" sendReasonPhraseYamlPath
    \"Warning\"\n    sendReasonPhraseYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${sendReasonPhraseYamlPath}\"
    ]]; then\n        return\n    fi\n    setSystemValue \"${sendReasonPhraseYamlPath}\"
    \"${sendReasonPhraseValue}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${sendReasonPhraseYamlPath}]
    with value [${sendReasonPhraseValue}] in system.yaml\"\n}\n\n# Updating system.yaml
    with Connector relaxedPathChars\nsetConnectorRelaxedPathChars () {\n    local
    yamlPath=\"$1\"\n    local relaxedPathCharsValue=\"$2\"\n    local relaxedPathCharsYamlPath=\n
    \   if [[ -z \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z  \"${relaxedPathCharsValue}\"
    ]]; then\n        return\n    fi\n    ## Getting relaxedPathChars yaml path from
    migration info yaml\n    retrieveYamlValue \"${yamlPath}\" relaxedPathCharsYamlPath
    \"Warning\"\n    relaxedPathCharsYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${relaxedPathCharsYamlPath}\"
    ]]; then\n        return\n    fi\n    setSystemValue \"${relaxedPathCharsYamlPath}\"
    \"${relaxedPathCharsValue}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${relaxedPathCharsYamlPath}]
    with value [${relaxedPathCharsValue}] in system.yaml\"\n}\n\n# Updating system.yaml
    with Connector relaxedQueryChars\nsetConnectorRelaxedQueryChars () {\n    local
    yamlPath=\"$1\"\n    local relaxedQueryCharsValue=\"$2\"\n    local relaxedQueryCharsYamlPath=\n
    \   if [[ -z \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z  \"${relaxedQueryCharsValue}\"
    ]]; then\n        return\n    fi\n    ## Getting relaxedQueryChars yaml path from
    migration info yaml\n    retrieveYamlValue \"${yamlPath}\" relaxedQueryCharsYamlPath
    \"Warning\"\n    relaxedQueryCharsYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${relaxedQueryCharsYamlPath}\"
    ]]; then\n        return\n    fi\n    setSystemValue \"${relaxedQueryCharsYamlPath}\"
    \"${relaxedQueryCharsValue}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting [${relaxedQueryCharsYamlPath}]
    with value [${relaxedQueryCharsValue}] in system.yaml\"\n}\n\n# Updating system.yaml
    with Connectors configurations\nsetConnectorExtraConfig () {\n    local yamlPath=\"$1\"\n
    \   local connectorAttributes=\"$2\"\n    local extraConfigPath=\n    if [[ -z
    \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z \"${connectorAttributes}\"
    ]]; then\n        return\n    fi\n    ## Getting extraConfig yaml path from migration
    info yaml\n    retrieveYamlValue \"${yamlPath}\" extraConfig \"Warning\"\n    extraConfigPath=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${extraConfigPath}\" ]]; then\n        return\n    fi\n    # strip
    leading and trailing spaces\n    connectorAttributes=$(io_trim \"${connectorAttributes}\")\n
    \   setSystemValue \"${extraConfigPath}\" \"${connectorAttributes}\" \"${SYSTEM_YAML_PATH}\"\n
    \   logger \"Setting [${extraConfigPath}] with connector attributes in system.yaml\"\n}\n\n#
    Updating system.yaml with extra Connectors\nsetExtraConnector () {\n    local
    yamlPath=\"$1\"\n    local extraConnector=\"$2\"\n    local extraConnectorYamlPath=\n
    \   if [[ -z \"${yamlPath}\" ]]; then\n        return\n    fi\n    if [[ -z \"${extraConnector}\"
    ]]; then\n        return\n    fi\n    ## Getting extraConnecotr yaml path from
    migration info yaml\n    retrieveYamlValue \"${yamlPath}\" extraConnectorYamlPath
    \"Warning\"\n    extraConnectorYamlPath=\"${YAML_VALUE}\"\n    if [[ -z \"${extraConnectorYamlPath}\"
    ]]; then\n        return\n    fi\n    getYamlValue  \"${extraConnectorYamlPath}\"
    \ \"${SYSTEM_YAML_PATH}\"  \"false\"\n    local connectorExtra=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${connectorExtra}\" ]]; then\n        setSystemValue \"${extraConnectorYamlPath}\"
    \"${extraConnector}\" \"${SYSTEM_YAML_PATH}\"\n        logger \"Setting [${extraConnectorYamlPath}]
    with extra connectors in system.yaml\"\n    else    \n        setSystemValue \"${extraConnectorYamlPath}\"
    \"\\\"${connectorExtra} ${extraConnector}\\\"\" \"${SYSTEM_YAML_PATH}\"\n        logger
    \"Setting [${extraConnectorYamlPath}] with extra connectors in system.yaml\"\n
    \   fi\n}\n\n# Migrate extra connectors to system.yaml\nmigrateExtraConnectors
    () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   local excludeDefaultPort=\"$4\"\n    local i=\"$5\"\n    local extraConfig=
    \n    local extraConnector=\n    if [[ \"${excludeDefaultPort}\" == \"yes\" ]];
    then\n        for ((i = 1 ; i <= \"${connectorCount}\" ; i++));\n        do  \n
    \           local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n
    \           [[ \"${portValue}\" != \"${DEFAULT_ACCESS_PORT}\" && \"${portValue}\"
    != \"${DEFAULT_RT_PORT}\" ]] || continue\n            extraConnector=$($LIBXML2_PATH
    --xpath '//Server/Service/Connector['$i']' ${filePath}/${fileName} 2>/dev/null)\n
    \           setExtraConnector \"${EXTRA_CONFIG_YAMLPATH}\" \"${extraConnector}\"
    \n        done\n    else\n        extraConnector=$($LIBXML2_PATH --xpath '//Server/Service/Connector['$i']'
    ${filePath}/${fileName} 2>/dev/null)\n        setExtraConnector \"${EXTRA_CONFIG_YAMLPATH}\"
    \"${extraConnector}\"\n    fi\n}\n\n# Migrate connector configurations\nmigrateConnectorConfig
    () {\n    local i=\"$1\"\n    local protocolType=\"$2\"\n    local portValue=\"$3\"\n
    \   local connectorPortYamlPath=\"$4\"\n    local connectorMaxThreadYamlPath=\"$5\"\n
    \   local connectorAttributesYamlPath=\"$6\"\n    local filePath=\"$7\"\n    local
    fileName=\"$8\"\n    local connectorSendReasonPhraseYamlPath=\"$9\"\n    local
    connectorRelaxedPathCharsYamlPath=\"${10}\"\n    local connectorRelaxedQueryCharsYamlPath=\"${11}\"\n
    \   \n    # migrate port\n    setConnectorPort \"${connectorPortYamlPath}\" \"${portValue}\"\n
    \   \n    # migrate maxThreads\n    local maxThreadValue=$(getXmlConnectorMaxThreads
    \"$i\" \"${filePath}\" \"${fileName}\")\n    setConnectorMaxThread \"${connectorMaxThreadYamlPath}\"
    \"${maxThreadValue}\"\n\n    # migrate sendReasonPhrase\n    local sendReasonPhraseValue=$(getXmlConnectorSendReasonPhrase
    \"$i\" \"${filePath}\" \"${fileName}\")\n    setConnectorSendReasonPhrase \"${connectorSendReasonPhraseYamlPath}\"
    \"${sendReasonPhraseValue}\"\n    \n    # migrate relaxedPathChars\n    local
    relaxedPathCharsValue=$(getXmlConnectorRelaxedPathChars \"$i\" \"${filePath}\"
    \"${fileName}\")\n    setConnectorRelaxedPathChars \"${connectorRelaxedPathCharsYamlPath}\"
    \"\\\"${relaxedPathCharsValue}\\\"\"\n    # migrate relaxedQueryChars\n    local
    relaxedQueryCharsValue=$(getXmlConnectorRelaxedQueryChars \"$i\" \"${filePath}\"
    \"${fileName}\")\n    setConnectorRelaxedQueryChars \"${connectorRelaxedQueryCharsYamlPath}\"
    \"\\\"${relaxedQueryCharsValue}\\\"\"\n\n    # migrate all attributes to extra
    config except port , maxThread , sendReasonPhrase ,relaxedPathChars and relaxedQueryChars\n
    \   local connectorAttributes=$(getXmlConnectorAttributes \"$i\" \"${filePath}\"
    \"${fileName}\")\n    connectorAttributes=$(echo \"${connectorAttributes}\" |
    sed 's/port=\"'${portValue}'\"//g' | sed 's/maxThreads=\"'${maxThreadValue}'\"//g'
    | sed 's/sendReasonPhrase=\"'${sendReasonPhraseValue}'\"//g' | sed 's/relaxedPathChars=\"\\'${relaxedPathCharsValue}'\\\"//g'
    | sed 's/relaxedQueryChars=\"\\'${relaxedQueryCharsValue}'\\\"//g')\n    # strip
    leading and trailing spaces\n    connectorAttributes=$(io_trim \"${connectorAttributes}\")\n
    \   setConnectorExtraConfig \"${connectorAttributesYamlPath}\" \"${connectorAttributes}\"\n}\n\n#
    Check for default port 8040 and 8081 in connectors and migrate\nmigrateConnectorPort
    () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   local defaultPort=\"$4\"\n    local connectorPortYamlPath=\"$5\"\n    local
    connectorMaxThreadYamlPath=\"$6\"\n    local connectorAttributesYamlPath=\"$7\"\n
    \   local connectorSendReasonPhraseYamlPath=\"$8\"\n    local connectorRelaxedPathCharsYamlPath=\"$9\"\n
    \   local connectorRelaxedQueryCharsYamlPath=\"${10}\"\n    local portYamlPath=\n
    \   local maxThreadYamlPath=\n    local status=\n    for ((i = 1 ; i <= \"${connectorCount}\"
    ; i++));\n    do  \n        local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\"
    \"${fileName}\")\n        local protocolType=$(getXmlConnectorProtocol \"$i\"
    \"${filePath}\" \"${fileName}\")\n        [[ \"${protocolType}\" == *AJP* ]] &&
    continue\n        [[ \"${portValue}\" != \"${defaultPort}\" ]] && continue\n        if
    [[ \"${portValue}\" == \"${DEFAULT_RT_PORT}\" ]]; then\n            RT_DEFAULTPORT_STATUS=success\n
    \       else\n            AC_DEFAULTPORT_STATUS=success\n        fi\n        migrateConnectorConfig
    \"${i}\" \"${protocolType}\" \"${portValue}\" \"${connectorPortYamlPath}\" \"${connectorMaxThreadYamlPath}\"
    \"${connectorAttributesYamlPath}\" \"${filePath}\" \"${fileName}\" \"${connectorSendReasonPhraseYamlPath}\"
    \"${connectorRelaxedPathCharsYamlPath}\" \"${connectorRelaxedQueryCharsYamlPath}\"\n
    \   done\n}\n\n# migrate to extra, connector having default port and protocol
    is AJP\nmigrateDefaultPortIfAjp () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n
    \   local connectorCount=\"$3\"\n    local defaultPort=\"$4\"\n    \n    for ((i
    = 1 ; i <= \"${connectorCount}\" ; i++));\n    do  \n        local portValue=$(getXmlConnectorPort
    \"$i\" \"${filePath}\" \"${fileName}\")\n        local protocolType=$(getXmlConnectorProtocol
    \"$i\" \"${filePath}\" \"${fileName}\")\n        [[ \"${protocolType}\" != *AJP*
    ]] && continue\n        [[ \"${portValue}\" != \"${defaultPort}\" ]] && continue\n
    \       migrateExtraConnectors \"${filePath}\" \"${fileName}\" \"${connectorCount}\"
    \"no\" \"${i}\"\n    done\n\n}\n\n# Comparing max threads in connectors\ncompareMaxThreads
    () {\n    local firstConnectorMaxThread=\"$1\"\n    local firstConnectorNode=\"$2\"\n
    \   local secondConnectorMaxThread=\"$3\"\n    local secondConnectorNode=\"$4\"\n
    \   local filePath=\"$5\"\n    local fileName=\"$6\"\n\n    # choose higher maxThreads
    connector as Artifactory.\n    if [[ \"${firstConnectorMaxThread}\" -gt ${secondConnectorMaxThread}
    || \"${firstConnectorMaxThread}\" -eq ${secondConnectorMaxThread} ]]; then\n        #
    maxThread is higher in firstConnector,\n        # Taking firstConnector as Artifactory
    and SecondConnector as Access\n        # maxThread is equal in both connector,considering
    firstConnector as Artifactory and SecondConnector as Access\n        local rtPortValue=$(getXmlConnectorPort
    \"${firstConnectorNode}\" \"${filePath}\" \"${fileName}\")\n        migrateConnectorConfig
    \"${firstConnectorNode}\" \"${protocolType}\" \"${rtPortValue}\" \"${RT_PORT_YAMLPATH}\"
    \"${RT_MAXTHREADS_YAMLPATH}\" \"${RT_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\"
    \"${RT_SENDREASONPHRASE_YAMLPATH}\" \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n
    \       local acPortValue=$(getXmlConnectorPort \"${secondConnectorNode}\" \"${filePath}\"
    \"${fileName}\")\n        migrateConnectorConfig \"${secondConnectorNode}\" \"${protocolType}\"
    \"${acPortValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\" \"${AC_EXTRACONFIG_YAMLPATH}\"
    \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n    else\n
    \       # maxThread is higher in SecondConnector, \n        # Taking SecondConnector
    as Artifactory and firstConnector as Access\n        local rtPortValue=$(getXmlConnectorPort
    \"${secondConnectorNode}\" \"${filePath}\" \"${fileName}\")\n        migrateConnectorConfig
    \"${secondConnectorNode}\" \"${protocolType}\" \"${rtPortValue}\" \"${RT_PORT_YAMLPATH}\"
    \"${RT_MAXTHREADS_YAMLPATH}\" \"${RT_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\"
    \"${RT_SENDREASONPHRASE_YAMLPATH}\" \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n
    \       local acPortValue=$(getXmlConnectorPort \"${firstConnectorNode}\" \"${filePath}\"
    \"${fileName}\")\n        migrateConnectorConfig \"${firstConnectorNode}\" \"${protocolType}\"
    \"${acPortValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\" \"${AC_EXTRACONFIG_YAMLPATH}\"
    \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n    fi\n}\n\n#
    Check max threads exist to compare\nmaxThreadsExistToCompare () {\n    local filePath=\"$1\"\n
    \   local fileName=\"$2\"\n    local connectorCount=\"$3\"\n    local firstConnectorMaxThread=\n
    \   local secondConnectorMaxThread=\n    local firstConnectorNode=\n    local
    secondConnectorNode=\n    local status=success\n    local firstnode=fail\n\n    for
    ((i = 1 ; i <= \"${connectorCount}\" ; i++));\n        do \n        local protocolType=$(getXmlConnectorProtocol
    \"$i\" \"${filePath}\" \"${fileName}\")\n        if [[ ${protocolType} == *AJP*
    ]]; then\n            # Migrate Connectors\n            migrateExtraConnectors
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"no\" \"${i}\"\n            continue\n
    \       fi\n        # store maxthreads value of each connector\n        if [[
    ${firstnode} == \"fail\" ]]; then\n            firstConnectorMaxThread=$(getXmlConnectorMaxThreads
    \"${i}\" \"${filePath}\" \"${fileName}\")\n            firstConnectorNode=\"${i}\"\n
    \           firstnode=success\n        else\n            secondConnectorMaxThread=$(getXmlConnectorMaxThreads
    \"${i}\" \"${filePath}\" \"${fileName}\")\n            secondConnectorNode=\"${i}\"\n
    \       fi\n    done\n    [[ -z \"${firstConnectorMaxThread}\" ]] && status=fail\n
    \   [[ -z \"${secondConnectorMaxThread}\" ]] && status=fail\n    # maxThreads
    is set, now compare MaxThreads\n    if [[ \"${status}\" == \"success\" ]]; then\n
    \       compareMaxThreads \"${firstConnectorMaxThread}\" \"${firstConnectorNode}\"
    \"${secondConnectorMaxThread}\" \"${secondConnectorNode}\" \"${filePath}\" \"${fileName}\"\n
    \   else \n        # Assume first connector is RT, maxThreads is not set in both
    connectors\n        local rtPortValue=$(getXmlConnectorPort \"${firstConnectorNode}\"
    \"${filePath}\" \"${fileName}\")\n        migrateConnectorConfig \"${firstConnectorNode}\"
    \"${protocolType}\" \"${rtPortValue}\" \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\"
    \"${RT_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${RT_SENDREASONPHRASE_YAMLPATH}\"
    \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n        local
    acPortValue=$(getXmlConnectorPort \"${secondConnectorNode}\" \"${filePath}\" \"${fileName}\")\n
    \       migrateConnectorConfig \"${secondConnectorNode}\" \"${protocolType}\"
    \"${acPortValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\" \"${AC_EXTRACONFIG_YAMLPATH}\"
    \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n    fi\n}\n\nmigrateExtraBasedOnNonAjpCount
    () {\n    local nonAjpCount=\"$1\"\n    local filePath=\"$2\"\n    local fileName=\"$3\"\n
    \   local connectorCount=\"$4\"\n    local i=\"$5\"\n\n    local protocolType=$(getXmlConnectorProtocol
    \"$i\" \"${filePath}\" \"${fileName}\")\n    if [[ \"${protocolType}\" == *AJP*
    ]]; then\n        if [[ \"${nonAjpCount}\" -eq 1  ]]; then\n            # migrateExtraConnectors\n
    \           migrateExtraConnectors \"${filePath}\" \"${fileName}\" \"${connectorCount}\"
    \"no\" \"${i}\"\n            continue\n        else\n            # migrateExtraConnectors\n
    \           migrateExtraConnectors \"${filePath}\" \"${fileName}\" \"${connectorCount}\"
    \"yes\"\n            continue\n        fi\n    fi\n}\n\n# find RT and AC Connector\nfindRtAndAcConnector
    () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   local initialAjpCount=0\n    local nonAjpCount=0\n\n    # get the count of
    non AJP\n    for ((i = 1 ; i <= \"${connectorCount}\" ; i++));\n    do  \n        local
    portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n        local
    protocolType=$(getXmlConnectorProtocol \"$i\" \"${filePath}\" \"${fileName}\")\n
    \       [[ \"${protocolType}\" != *AJP* ]]  || continue\n        nonAjpCount=$((initialAjpCount+1))\n
    \       initialAjpCount=\"${nonAjpCount}\"\n    done\n    if [[ \"${nonAjpCount}\"
    -eq 1 ]]; then  \n        # Add the connector found as access and artifactory
    connectors\n        # Mark port as 8040 for access\n        for ((i = 1 ; i <=
    \"${connectorCount}\" ; i++))\n        do  \n            migrateExtraBasedOnNonAjpCount
    \"${nonAjpCount}\" \"${filePath}\" \"${fileName}\" \"${connectorCount}\"  \"$i\"\n
    \           local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n
    \           migrateConnectorConfig \"$i\" \"${protocolType}\" \"${portValue}\"
    \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\" \"${RT_EXTRACONFIG_YAMLPATH}\"
    \"${filePath}\" \"${fileName}\" \"${RT_SENDREASONPHRASE_YAMLPATH}\" \"${RT_RELAXEDPATHCHARS_YAMLPATH}\"
    \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n            migrateConnectorConfig \"$i\"
    \"${protocolType}\" \"${portValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\"
    \"${AC_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n
    \           setConnectorPort \"${AC_PORT_YAMLPATH}\" \"${DEFAULT_ACCESS_PORT}\"\n
    \       done\n    elif [[ \"${nonAjpCount}\" -eq 2 ]]; then\n        # compare
    maxThreads in both connectors\n        maxThreadsExistToCompare \"${filePath}\"
    \"${fileName}\" \"${connectorCount}\"\n    elif [[ \"${nonAjpCount}\" -gt 2 ]];
    then\n        # migrateExtraConnectors\n        migrateExtraConnectors \"${filePath}\"
    \"${fileName}\" \"${connectorCount}\" \"yes\"\n    elif [[ \"${nonAjpCount}\"
    -eq 0 ]]; then\n        # setting with default port in system.yaml\n        setConnectorPort
    \"${RT_PORT_YAMLPATH}\" \"${DEFAULT_RT_PORT}\"\n        setConnectorPort \"${AC_PORT_YAMLPATH}\"
    \"${DEFAULT_ACCESS_PORT}\"\n        # migrateExtraConnectors\n        migrateExtraConnectors
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"yes\"\n    fi\n}\n\n#
    get the count of non AJP\ngetCountOfNonAjp () {\n    local port=\"$1\"\n    local
    connectorCount=\"$2\"\n    local filePath=$3\n    local fileName=$4\n    local
    initialNonAjpCount=0\n\n    for ((i = 1 ; i <= \"${connectorCount}\" ; i++));\n
    \   do  \n        local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\"
    \"${fileName}\")\n        local protocolType=$(getXmlConnectorProtocol \"$i\"
    \"${filePath}\" \"${fileName}\")\n        [[ \"${portValue}\" != \"${port}\" ]]
    || continue\n        [[ \"${protocolType}\" != *AJP* ]]  || continue\n        local
    nonAjpCount=$((initialNonAjpCount+1))\n        initialNonAjpCount=\"${nonAjpCount}\"\n
    \   done\n    echo -e \"${nonAjpCount}\"\n}\n\n# Find for access connector\nfindAcConnector
    () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   \n    # get the count of non AJP \n    local nonAjpCount=$(getCountOfNonAjp
    \"${DEFAULT_RT_PORT}\" \"${connectorCount}\" \"${filePath}\" \"${fileName}\")\n
    \   if [[ \"${nonAjpCount}\" -eq 1 ]]; then\n        # Add the connector found
    as access connector and mark port as that of connector\n        for ((i = 1 ;
    i <= \"${connectorCount}\" ; i++))\n        do  \n            migrateExtraBasedOnNonAjpCount
    \"${nonAjpCount}\" \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"$i\"\n
    \           local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n
    \           if [[ \"${portValue}\" != \"${DEFAULT_RT_PORT}\" ]]; then\n                migrateConnectorConfig
    \"$i\" \"${protocolType}\" \"${portValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\"
    \"${AC_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n
    \           fi   \n        done\n    elif [[ \"${nonAjpCount}\" -gt 1 ]]; then\n
    \       # Take RT properties into access with 8040\n        for ((i = 1 ; i <=
    \"${connectorCount}\" ; i++))\n        do  \n            migrateExtraBasedOnNonAjpCount
    \"${nonAjpCount}\" \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"$i\"\n
    \           local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n
    \           if [[ \"${portValue}\" == \"${DEFAULT_RT_PORT}\" ]]; then\n                migrateConnectorConfig
    \"$i\" \"${protocolType}\" \"${portValue}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\"
    \"${AC_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n
    \               setConnectorPort \"${AC_PORT_YAMLPATH}\" \"${DEFAULT_ACCESS_PORT}\"\n
    \           fi\n        done\n    elif [[ \"${nonAjpCount}\" -eq 0 ]]; then \n
    \       # Add RT connector details as access connector and mark port as 8040  \n
    \       migrateConnectorPort \"${filePath}\" \"${fileName}\" \"${connectorCount}\"
    \"${DEFAULT_RT_PORT}\" \"${AC_PORT_YAMLPATH}\" \"${AC_MAXTHREADS_YAMLPATH}\" \"${AC_EXTRACONFIG_YAMLPATH}\"
    \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n        setConnectorPort \"${AC_PORT_YAMLPATH}\"
    \"${DEFAULT_ACCESS_PORT}\"\n        # migrateExtraConnectors\n        migrateExtraConnectors
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"yes\"\n    fi\n}\n\n#
    Find for artifactory connector\nfindRtConnector () {\n    local filePath=\"$1\"\n
    \   local fileName=\"$2\"\n    local connectorCount=\"$3\"\n    \n    # get the
    count of non AJP \n    local nonAjpCount=$(getCountOfNonAjp \"${DEFAULT_ACCESS_PORT}\"
    \"${connectorCount}\" \"${filePath}\" \"${fileName}\")\n    if [[ \"${nonAjpCount}\"
    -eq 1 ]]; then\n        # Add the connector found as RT connector\n        for
    ((i = 1 ; i <= \"${connectorCount}\" ; i++))\n        do  \n            migrateExtraBasedOnNonAjpCount
    \"${nonAjpCount}\" \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"$i\"\n
    \           local portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n
    \           if [[ \"${portValue}\" != \"${DEFAULT_ACCESS_PORT}\" ]]; then\n                migrateConnectorConfig
    \"$i\" \"${protocolType}\" \"${portValue}\" \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\"
    \"${RT_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${RT_SENDREASONPHRASE_YAMLPATH}\"
    \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n            fi\n
    \       done\n    elif [[ \"${nonAjpCount}\" -gt 1 ]]; then\n        # Take access
    properties into artifactory with 8081\n        for ((i = 1 ; i <= \"${connectorCount}\"
    ; i++))\n        do  \n            migrateExtraBasedOnNonAjpCount \"${nonAjpCount}\"
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"$i\"\n            local
    portValue=$(getXmlConnectorPort \"$i\" \"${filePath}\" \"${fileName}\")\n            if
    [[ \"${portValue}\" == \"${DEFAULT_ACCESS_PORT}\" ]]; then\n                migrateConnectorConfig
    \"$i\" \"${protocolType}\" \"${portValue}\" \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\"
    \"${RT_EXTRACONFIG_YAMLPATH}\" \"${filePath}\" \"${fileName}\" \"${RT_SENDREASONPHRASE_YAMLPATH}\"
    \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n                setConnectorPort
    \"${RT_PORT_YAMLPATH}\" \"${DEFAULT_RT_PORT}\"\n            fi\n        done\n
    \   elif [[ \"${nonAjpCount}\" -eq 0 ]]; then   \n        # Add access connector
    details as RT connector and mark as ${DEFAULT_RT_PORT}\n        migrateConnectorPort
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"${DEFAULT_ACCESS_PORT}\"
    \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\" \"${RT_EXTRACONFIG_YAMLPATH}\"
    \"${RT_SENDREASONPHRASE_YAMLPATH}\" \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n
    \       setConnectorPort \"${RT_PORT_YAMLPATH}\" \"${DEFAULT_RT_PORT}\"\n        #
    migrateExtraConnectors\n        migrateExtraConnectors \"${filePath}\" \"${fileName}\"
    \"${connectorCount}\" \"yes\"\n    fi\n}\n\ncheckForTlsConnector () {\n    local
    filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   for ((i = 1 ; i <= \"${connectorCount}\" ; i++))\n    do\n        local sslProtocolValue=$($LIBXML2_PATH
    --xpath '//Server/Service/Connector['$i']/@sslProtocol' ${filePath}/${fileName}
    2>/dev/null | awk -F\"=\" '{print $2}' | tr -d '\"')\n        if [[ \"${sslProtocolValue}\"
    == \"TLS\" ]]; then\n            bannerImportant \"NOTE: Ignoring TLS connector
    during migration, modify the system yaml to enable TLS. Original server.xml is
    saved in path [${filePath}/${fileName}]\"\n            TLS_CONNECTOR_EXISTS=${FLAG_Y}\n
    \           continue\n        fi\n    done\n}\n\n# set custom tomcat server Listeners
    to system.yaml\nsetListenerConnector () {\n    local filePath=\"$1\"\n    local
    fileName=\"$2\"\n    local listenerCount=\"$3\"\n    for ((i = 1 ; i <= \"${listenerCount}\"
    ; i++))\n    do \n        local listenerConnector=$($LIBXML2_PATH --xpath '//Server/Listener['$i']'
    ${filePath}/${fileName} 2>/dev/null)\n        local listenerClassName=$($LIBXML2_PATH
    --xpath '//Server/Listener['$i']/@className' ${filePath}/${fileName} 2>/dev/null
    | awk -F\"=\" '{print $2}' | tr -d '\"')\n        if [[ \"${listenerClassName}\"
    == *Apr* ]]; then\n            setExtraConnector \"${EXTRA_LISTENER_CONFIG_YAMLPATH}\"
    \"${listenerConnector}\"\n        fi\n    done\n}\n# add custom tomcat server
    Listeners\naddTomcatServerListeners () {\n    local filePath=\"$1\"\n    local
    fileName=\"$2\"\n    local listenerCount=\"$3\"\n    if [[ \"${listenerCount}\"
    == \"0\" ]]; then\n        logger \"No listener connectors found in the [${filePath}/${fileName}],skipping
    migration of listener connectors\"\n    else\n        setListenerConnector \"${filePath}\"
    \"${fileName}\" \"${listenerCount}\"\n        setSystemValue \"${RT_TOMCAT_HTTPSCONNECTOR_ENABLED}\"
    \"true\" \"${SYSTEM_YAML_PATH}\"\n        logger \"Setting [${RT_TOMCAT_HTTPSCONNECTOR_ENABLED}]
    with value [true] in system.yaml\"\n    fi\n}\n\n# server.xml migration operations\nxmlMigrateOperation
    () {\n    local filePath=\"$1\"\n    local fileName=\"$2\"\n    local connectorCount=\"$3\"\n
    \   local listenerCount=\"$4\"\n    RT_DEFAULTPORT_STATUS=fail\n    AC_DEFAULTPORT_STATUS=fail\n
    \   TLS_CONNECTOR_EXISTS=${FLAG_N}\n\n    # Check for connector with TLS , if
    found ignore migrating it\n    checkForTlsConnector \"${filePath}\" \"${fileName}\"
    \"${connectorCount}\"\n    if [[ \"${TLS_CONNECTOR_EXISTS}\" == \"${FLAG_Y}\"
    ]]; then\n        return\n    fi\n    addTomcatServerListeners \"${filePath}\"
    \"${fileName}\" \"${listenerCount}\"\n    # Migrate RT default port from connectors
    \n    migrateConnectorPort \"${filePath}\" \"${fileName}\" \"${connectorCount}\"
    \"${DEFAULT_RT_PORT}\" \"${RT_PORT_YAMLPATH}\" \"${RT_MAXTHREADS_YAMLPATH}\" \"${RT_EXTRACONFIG_YAMLPATH}\"
    \"${RT_SENDREASONPHRASE_YAMLPATH}\" \"${RT_RELAXEDPATHCHARS_YAMLPATH}\" \"${RT_RELAXEDQUERYCHARS_YAMLPATH}\"\n
    \   # Migrate to extra if RT default ports are AJP\n    migrateDefaultPortIfAjp
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"${DEFAULT_RT_PORT}\"\n
    \   # Migrate AC default port from connectors\n    migrateConnectorPort \"${filePath}\"
    \"${fileName}\" \"${connectorCount}\" \"${DEFAULT_ACCESS_PORT}\" \"${AC_PORT_YAMLPATH}\"
    \"${AC_MAXTHREADS_YAMLPATH}\" \"${AC_EXTRACONFIG_YAMLPATH}\" \"${AC_SENDREASONPHRASE_YAMLPATH}\"\n
    \   # Migrate to extra if access default ports are AJP\n    migrateDefaultPortIfAjp
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"${DEFAULT_ACCESS_PORT}\"\n\n
    \   if [[ \"${AC_DEFAULTPORT_STATUS}\" == \"success\" && \"${RT_DEFAULTPORT_STATUS}\"
    == \"success\" ]]; then\n        # RT and AC default port found\n        logger
    \"Artifactory 8081 and Access 8040 default port are found\"\n        migrateExtraConnectors
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\" \"yes\"\n    elif [[ \"${AC_DEFAULTPORT_STATUS}\"
    == \"success\" && \"${RT_DEFAULTPORT_STATUS}\" == \"fail\" ]]; then\n        #
    Only AC default port found,find RT connector\n        logger \"Found Access default
    8040 port\"\n        findRtConnector \"${filePath}\" \"${fileName}\" \"${connectorCount}\"\n
    \   elif [[ \"${AC_DEFAULTPORT_STATUS}\" == \"fail\" && \"${RT_DEFAULTPORT_STATUS}\"
    == \"success\" ]]; then\n        # Only RT default port found,find AC connector\n
    \       logger \"Found Artifactory default 8081 port\"\n        findAcConnector
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\"\n    elif [[ \"${AC_DEFAULTPORT_STATUS}\"
    == \"fail\" && \"${RT_DEFAULTPORT_STATUS}\" == \"fail\" ]]; then    \n        #
    RT and AC default port not found, find connector\n        logger \"Artifactory
    8081 and Access 8040 default port are not found\"\n        findRtAndAcConnector
    \"${filePath}\" \"${fileName}\" \"${connectorCount}\"\n    fi\n}\n\n# get count
    of connectors\ngetXmlConnectorCount () {\n    local filePath=\"$1\"\n    local
    fileName=\"$2\"\n    local count=$($LIBXML2_PATH --xpath 'count(/Server/Service/Connector)'
    ${filePath}/${fileName})\n    echo -e \"${count}\"\n}\n\n# get count of listener
    connectors\ngetTomcatServerListenersCount () {\n    local filePath=\"$1\"\n    local
    fileName=\"$2\"\n    local count=$($LIBXML2_PATH --xpath 'count(/Server/Listener)'
    ${filePath}/${fileName})\n    echo -e \"${count}\"\n}\n\n# Migrate server.xml
    configuration to system.yaml\nmigrateXmlFile () {\n    local xmlFiles=\n    local
    fileName=\n    local filePath=\n    local sourceFilePath=\n    DEFAULT_ACCESS_PORT=\"8040\"\n
    \   DEFAULT_RT_PORT=\"8081\"\n    AC_PORT_YAMLPATH=\"migration.xmlFiles.serverXml.access.port\"\n
    \   AC_MAXTHREADS_YAMLPATH=\"migration.xmlFiles.serverXml.access.maxThreads\"\n
    \   AC_SENDREASONPHRASE_YAMLPATH=\"migration.xmlFiles.serverXml.access.sendReasonPhrase\"\n
    \   AC_EXTRACONFIG_YAMLPATH=\"migration.xmlFiles.serverXml.access.extraConfig\"\n
    \   RT_PORT_YAMLPATH=\"migration.xmlFiles.serverXml.artifactory.port\"\n    RT_MAXTHREADS_YAMLPATH=\"migration.xmlFiles.serverXml.artifactory.maxThreads\"\n
    \   RT_SENDREASONPHRASE_YAMLPATH='migration.xmlFiles.serverXml.artifactory.sendReasonPhrase'\n
    \   RT_RELAXEDPATHCHARS_YAMLPATH='migration.xmlFiles.serverXml.artifactory.relaxedPathChars'\n
    \   RT_RELAXEDQUERYCHARS_YAMLPATH='migration.xmlFiles.serverXml.artifactory.relaxedQueryChars'\n
    \   RT_EXTRACONFIG_YAMLPATH=\"migration.xmlFiles.serverXml.artifactory.extraConfig\"\n
    \   ROUTER_PORT_YAMLPATH=\"migration.xmlFiles.serverXml.router.port\"\n    EXTRA_CONFIG_YAMLPATH=\"migration.xmlFiles.serverXml.extra.config\"\n
    \   EXTRA_LISTENER_CONFIG_YAMLPATH=\"migration.xmlFiles.serverXml.extra.listener\"\n
    \   RT_TOMCAT_HTTPSCONNECTOR_ENABLED=\"artifactory.tomcat.httpsConnector.enabled\"\n\n
    \   retrieveYamlValue \"migration.xmlFiles\" \"xmlFiles\" \"Skip\"\n    xmlFiles=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${xmlFiles}\" ]]; then\n        return\n    fi\n    bannerSection
    \"PROCESSING MIGRATION OF XML FILES\"\n    retrieveYamlValue \"migration.xmlFiles.serverXml.fileName\"
    \"fileName\" \"Warning\"\n    fileName=\"${YAML_VALUE}\"\n    if [[ -z \"${fileName}\"
    ]]; then\n        return\n    fi\n    bannerSubSection \"Processing Migration
    of $fileName\"\n    retrieveYamlValue \"migration.xmlFiles.serverXml.filePath\"
    \"filePath\" \"Warning\"\n    filePath=\"${YAML_VALUE}\"\n    if [[ -z \"${filePath}\"
    ]]; then\n        return\n    fi\n    # prepend NEW_DATA_DIR only if filePath
    is relative path\n    sourceFilePath=$(prependDir \"${filePath}\" \"${NEW_DATA_DIR}/${filePath}\")\n
    \   if [[ \"$(checkFileExists \"${sourceFilePath}/${fileName}\")\" == \"true\"
    ]]; then\n        logger \"File [${fileName}] is found in path [${sourceFilePath}]\"\n
    \       local connectorCount=$(getXmlConnectorCount \"${sourceFilePath}\" \"${fileName}\")\n
    \       if [[ \"${connectorCount}\" == \"0\" ]]; then\n            logger \"No
    connectors found in the [${filePath}/${fileName}],skipping migration of xml configuration\"\n
    \           return\n        fi\n        local listenerCount=$(getTomcatServerListenersCount
    \"${sourceFilePath}\" \"${fileName}\")\n        xmlMigrateOperation \"${sourceFilePath}\"
    \"${fileName}\" \"${connectorCount}\" \"${listenerCount}\"\n    else\n        logger
    \"File [${fileName}] is not found in path [${sourceFilePath}] to migrate\"\n    fi
    \  \n}\n\ncompareArtifactoryUser () {\n    local property=\"$1\"\n    local oldPropertyValue=\"$2\"\n
    \   local newPropertyValue=\"$3\"\n    local yamlPath=\"$4\"\n    local sourceFile=\"$5\"\n\n
    \   if [[ \"${oldPropertyValue}\" != \"${newPropertyValue}\" ]]; then\n        setSystemValue
    \"${yamlPath}\" \"${oldPropertyValue}\" \"${SYSTEM_YAML_PATH}\"\n        logger
    \"Setting [${yamlPath}] with value of the property [${property}] in system.yaml\"\n
    \   else\n        logger \"No change in property [${property}] value in [${sourceFile}]
    to migrate\"\n    fi\n}\n\nmigrateReplicator () {\n    local property=\"$1\"\n
    \   local oldPropertyValue=\"$2\"\n    local yamlPath=\"$3\"\n\n    setSystemValue
    \"${yamlPath}\" \"${oldPropertyValue}\" \"${SYSTEM_YAML_PATH}\"\n    logger \"Setting
    [${yamlPath}] with value of the property [${property}] in system.yaml\"\n}\n\ncompareJavaOptions
    () {\n    local property=\"$1\"\n    local oldPropertyValue=\"$2\"\n    local
    newPropertyValue=\"$3\"\n    local yamlPath=\"$4\"\n    local sourceFile=\"$5\"\n
    \   local oldJavaOption=\n    local newJavaOption=\n    local extraJavaOption=\n
    \   local check=false\n    local success=true\n    local status=true\n\n    oldJavaOption=$(echo
    \"${oldPropertyValue}\" | awk 'BEGIN{FS=OFS=\"\\\"\"}{for(i=2;i<NF;i+=2)gsub(/
    /,\"@\",$i)}1')\n    newJavaOption=$(echo \"${newPropertyValue}\" | awk 'BEGIN{FS=OFS=\"\\\"\"}{for(i=2;i<NF;i+=2)gsub(/
    /,\"@\",$i)}1')\n    for oldJavaOption in $oldPropertyValue;\n    do\n        for
    newJavaOption in $newPropertyValue;\n        do\n            if [[ \"${oldJavaOption}\"
    == \"${newJavaOption}\" ]]; then\n                check=true\n                break\n
    \           else\n                check=false\n            fi\n        done\n
    \       if [[ \"${check}\" == \"false\" ]]; then\n            oldJavaOption=$(echo
    \"${oldJavaOption}\" | tr -s \"@\" \" \")\n            getYamlValue \"${yamlPath}\"
    \"${SYSTEM_YAML_PATH}\" \"false\"\n            extraJavaOption=\"${YAML_VALUE}\"\n
    \           success=false\n            if [[ -z \"${extraJavaOption}\" ]]; then\n
    \               setSystemValue \"${yamlPath}\" \"\\\"${oldJavaOption}\\\"\" \"${SYSTEM_YAML_PATH}\"
    && status=false\n            else\n                [[ \"${extraJavaOption}\" !=
    *\"${oldJavaOption}\"* ]] && setSystemValue \"${yamlPath}\" \"\\\"${extraJavaOption}
    ${oldJavaOption}\\\"\" \"${SYSTEM_YAML_PATH}\" || status=false\n            fi\n
    \       fi\n    done\n    if [[ \"${status}\" == \"false\" ]]; then\n        getYamlValue
    \"${yamlPath}\" \"${SYSTEM_YAML_PATH}\" \"false\"\n        local extraOpts=\"${YAML_VALUE}\"\n
    \       logger \"Setting [${yamlPath}] with value of the property [${property}]
    in system.yaml\"\n    fi\n    [[ \"${success}\" == \"true\" && \"${check}\" ==
    \"true\" ]] && logger \"No change in property [JAVA_OPTIONS] value in [${sourceFile}]
    to migrate\"\n}\n\ndefaultPropertyMigrate () {\n    local entry=\"$1\"\n    local
    sourceFile=\"$2\"\n    local targetFile=\"$3\"\n    local yamlPath=\n    local
    property=\n    local oldPropertyValue=\n    local newPropertyValue=\n    local
    check=false\n    \n    local targetDataDir=\n\n    local yamlPath=$(getFirstEntry
    \"${entry}\")\n    local property=$(getSecondEntry \"${entry}\")\n    if [[ -z
    \"${property}\" ]]; then\n        warn \"Property is empty in map [${entry}] in
    the file [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n    fi\n    if [[
    -z \"${yamlPath}\" ]]; then\n        warn \"yamlPath is empty for [${property}]
    in [${MIGRATION_SYSTEM_YAML_INFO}]\"\n        return\n    fi\n    unset ${property}\n
    \   source ${sourceFile}\n    oldPropertyValue=$(evalVariable \"oldPropertyValue\"
    \"${property}\")\n\n    unset ${property}\n    source ${targetFile}\n    if [[
    \"${property}\" == \"JAVA_OPTIONS\" ]]; then\n        property=\"DEFAULT_JAVA_OPTIONS\"\n
    \   fi\n    newPropertyValue=\"$(evalVariable \"newPropertyValue\" \"${property}\")\"\n\n
    \   [[ -z \"${oldPropertyValue}\" ]] && logger \"Property [${property}] not found
    in [${sourceFile}] to migrate\" || check=true\n    if [[ \"${check}\" == \"true\"
    ]]; then\n        # migrate ARTIFACTORY_USER\n        [[ \"${property}\" == \"ARTIFACTORY_USER\"
    ]] && compareArtifactoryUser \"${property}\" \"${oldPropertyValue}\" \"${newPropertyValue}\"
    \"${yamlPath}\" \"${sourceFile}\"\n        # migrate JAVA_OPTIONS\n        [[
    \"${property}\" == *\"JAVA_OPTIONS\"* ]] && compareJavaOptions \"${property}\"
    \"${oldPropertyValue}\" \"${newPropertyValue}\" \"${yamlPath}\" \"${sourceFile}\"\n
    \       # migrate START_LOCAL_REPLICATOR\n        [[ \"${property}\" == \"START_LOCAL_REPLICATOR\"
    ]] && migrateReplicator \"${property}\" \"${oldPropertyValue}\" \"${yamlPath}\"\n
    \   fi\n}\n\nmigrateDefaultFile () {\n    local oldDefaultFilePath=\n    local
    newDefaultFilePath=\n    local oldfileName=\n    local newFileName=\n    local
    map=\n    local defaultFile=\n    local sourceFilePath=\n    local targetFilePath=\n
    \   local sourceFile=\n    local targetFile=\n    \n    retrieveYamlValue \"migration.defaultFile\"
    \"defaultFile\" \"Skip\"\n    defaultFile=\"${YAML_VALUE}\"\n    if [[ -z \"${defaultFile}\"
    ]]; then\n        return\n    fi\n    bannerSection \"PROCESSING MIGRATION OF
    DEFAULTFILE\"\n    retrieveYamlValue \"migration.defaultFile.oldFile.defaultFilePath\"
    \"oldDefaultFilePath\" \"Warning\"\n    oldDefaultFilePath=\"${YAML_VALUE}\"\n
    \   retrieveYamlValue \"migration.defaultFile.oldFile.fileName\" \"oldFileName\"
    \"Warning\"\n    oldFileName=\"${YAML_VALUE}\"\n    if [[ \"$(warnIfEmpty \"${oldDefaultFilePath}\"
    \"migration.defaultFile.oldFile.defaultFilePath\")\" != \"true\" ]]; then\n        return\n
    \   fi\n    if [[ \"$(warnIfEmpty \"${oldFileName}\" \"migration.defaultFile.oldFile.fileName\")\"
    != \"true\" ]]; then\n        return\n    fi\n    retrieveYamlValue \"migration.defaultFile.newFile.defaultFilePath\"
    \"newDefaultFilePath\" \"Warning\"\n    newDefaultFilePath=\"${YAML_VALUE}\"\n
    \   retrieveYamlValue \"migration.defaultFile.newFile.fileName\" \"newfileName\"
    \"Warning\"\n    newFileName=\"${YAML_VALUE}\"\n    if [[ \"$(warnIfEmpty \"${newDefaultFilePath}\"
    \"migration.defaultFile.newFile.defaultFilePath\")\" != \"true\" ]]; then\n        return\n
    \   fi\n    if [[ \"$(warnIfEmpty \"${newFileName}\" \"migration.defaultFile.newFile.fileName\")\"
    != \"true\" ]]; then\n        return\n    fi\n    # prepend NEW_DATA_DIR only
    if oldDefaultFilePath is relative path\n    sourceFilePath=$(prependDir \"${oldDefaultFilePath}\"
    ${NEW_DATA_DIR}/${oldDefaultFilePath})\n    sourceFile=\"${sourceFilePath}/${oldFileName}\"\n
    \   if [[ \"$(checkFileExists \"${sourceFile}\")\" != \"true\" ]]; then\n        logger
    \"OldDefaultFile [${oldFileName}] not found in the path [${sourceFilePath}]\"\n
    \       return\n    fi\n    # path newDefaultFilePath will change based installer\n
    \   if [[ \"${INSTALLER}\" == \"${ZIP_TYPE}\" ]]; then\n        targetFilePath=\"${APP_DIR}/../${newDefaultFilePath}\"\n
    \   else\n        targetDataDir=\"`cd \"${NEW_DATA_DIR}\"/../;pwd`\"\n        targetFilePath=\"${targetDataDir}/${newDefaultFilePath}\"\n
    \   fi\n    targetFile=\"${targetFilePath}/${newFileName}\"\n    if [[ \"$(checkFileExists
    \"${targetFile}\")\" != \"true\" ]]; then\n        logger \"NewDefaultFile [${newFileName}]
    not found in the path [${sourceFilePath}]\"\n        return\n    fi\n    logger
    \"OldDefaultFile [${oldFileName}] found in the path [${sourceFilePath}]\"\n    logger
    \"NewDefaultFile [${newFileName}] found in the path [${targetFilePath}]\"\n    retrieveYamlValue
    \"migration.defaultFile.map\" \"map\" \"Warning\"\n    map=\"${YAML_VALUE}\"\n
    \   [[ -z \"${map}\" ]] && continue\n    for entry in $map;\n    do\n        if
    [[ \"$(checkMapEntry \"${entry}\")\" == \"true\" ]]; then\n            defaultPropertyMigrate
    \"${entry}\" \"${sourceFile}\" \"${targetFile}\"\n        else\n            warn
    \"map entry [${entry}] in [${MIGRATION_SYSTEM_YAML_INFO}] is not in correct format,
    correct format i.e yamlPath=property\"\n        fi\n    done\n}\n\n# comment node.id
    in system.yaml\n# Add a commented Line above the node.id in system.yaml\ncommentNodeId
    () {\n    local filePath=\n    local fileName=\n    local idKey=\n\n    retrieveYamlValue
    \"migration.propertyFiles.haNodeProperty.filePath\" \"filePath\" \"Skip\"\n    filePath=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${filePath}\" ]]; then\n        return\n    fi\n    retrieveYamlValue
    \"migration.propertyFiles.haNodeProperty.fileName\" \"fileName\" \"Skip\"\n    fileName=\"${YAML_VALUE}\"\n
    \   if [[ -z \"${fileName}\" ]]; then\n        return\n    fi\n    if [[ \"$(checkFileExists
    \"${NEW_DATA_DIR}/${filePath}/${fileName}\")\" == \"true\" ]]; then\n        getYamlValue
    \"shared.node\" \"${SYSTEM_YAML_PATH}\" \"false\"\n        idKey=$(echo \"${YAML_VALUE}\"
    | grep \"^id:\")\n        local regexString=\"${idKey}\"\n        local replaceText=\"#&\"\n
    \       replaceText_migration_hook \"${regexString}\" \"${replaceText}\" \"${SYSTEM_YAML_PATH}\"\n
    \       local text=\"# NOTE: node.id can be automatically determined based on
    the current hostname or be set using the SHARED_NODE_ID environment variable.
    There is no need to explicitly specify it here.\"\n        prependText \"${regexString}\"
    \"${text}\" \"${SYSTEM_YAML_PATH}\"\n    fi\n}\n\nartifactoryInfoMessage () {\n\n
    \   if [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\"
    ]]; then\n        addText \"# yamlFile was generated from db.properties,replicator.yaml
    and ha-node.properties config files.\" \"${SYSTEM_YAML_PATH}\"\n    else\n        addText
    \"# yamlFile was generated from default file,replicator.yaml,db.properties and
    ha-node.properties config files.\" \"${SYSTEM_YAML_PATH}\"\n    fi\n\n}\n\nreplicatorProfiling
    () {\n\n    if [[ \"${key}\" == \"profilingDisabled\" ]]; then\n        if [[
    ! -z \"${value}\" ]]; then\n            if [[ \"${value}\" == \"false\" ]]; then\n
    \               value=\"true\"\n            else\n                value=\"false\"\n
    \           fi\n        fi\n    fi\n}\n\nsetHaEnabled_hook () {\n    local filePath=\"$1\"\n
    \   if [[ \"$(checkFileExists \"${NEW_DATA_DIR}/${filePath}/ha-node.properties\")\"
    == \"true\" ]]; then\n        setSystemValue \"shared.node.haEnabled\" \"true\"
    \"${SYSTEM_YAML_PATH}\"\n        logger \"Setting [shared.node.haEnabled] with
    [true] in system.yaml\"\n    fi\n}\n\nremoveFileOperation () {\n    local backupDir=\"$1\"\n
    \   local file=\"$2\"\n    if [[ \"$(checkFileExists \"${file}\")\" == \"true\"
    ]]; then\n        cp -pf \"${file}\" \"${backupDir}\" || warn \"Failed to copy
    file [${file}] to ${backupDir}\"\n        rm -f \"${file}\" || warn \"Failed to
    remove file [${file}]\"\n    else\n        logger \"Source file [${file}] does
    not exist in path to backup and remove\"\n    fi\n}\n\n_createBackupOfLogBackDir
    () {\n    local backupDir=\"$1\"\n    local accessLogbackFile=\"${NEW_DATA_DIR}/etc/access/logback.xml\"\n
    \   local artiLogbackFile=\"${NEW_DATA_DIR}/etc/artifactory/logback.xml\"\n    local
    effectiveUser=\n    local effectiveGroup=\n    if [[ \"${INSTALLER}\" == \"${COMPOSE_TYPE}\"
    || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        effectiveUser=\"${JF_USER}\"\n
    \       effectiveGroup=\"${JF_USER}\"\n    elif [[ \"${INSTALLER}\" == \"${DEB_TYPE}\"
    || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        effectiveUser=\"${USER_TO_CHECK}\"
    \n        effectiveGroup=\"${GROUP_TO_CHECK}\"\n    fi\n    removeSoftLinkAndCreateDir
    \"${backupDir}/logbackXmlFiles\" \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n
    \   removeSoftLinkAndCreateDir \"${backupDir}/logbackXmlFiles/access\" \"${effectiveUser}\"
    \"${effectiveGroup}\" \"yes\" \n    removeSoftLinkAndCreateDir \"${backupDir}/logbackXmlFiles/artifactory\"
    \"${effectiveUser}\" \"${effectiveGroup}\" \"yes\"\n    removeFileOperation \"${backupDir}/logbackXmlFiles/access\"
    \"${accessLogbackFile}\"\n    removeFileOperation \"${backupDir}/logbackXmlFiles/artifactory\"
    \"${artiLogbackFile}\"\n}\n\n\n_createBackupOfReplicatorRtYaml () {\n    local
    backupDir=\"$1\"\n    local replicatorRtYamlFile=\"${NEW_DATA_DIR}/etc/replicator/replicator.artifactory.yaml\"\n
    \   local effectiveUser=\n    local effectiveGroup=\n    if [[ \"${INSTALLER}\"
    == \"${COMPOSE_TYPE}\" || \"${INSTALLER}\" == \"${HELM_TYPE}\" ]]; then\n        effectiveUser=\"${JF_USER}\"\n
    \       effectiveGroup=\"${JF_USER}\"\n    elif [[ \"${INSTALLER}\" == \"${DEB_TYPE}\"
    || \"${INSTALLER}\" == \"${RPM_TYPE}\" ]]; then\n        effectiveUser=\"${USER_TO_CHECK}\"
    \n        effectiveGroup=\"${GROUP_TO_CHECK}\"\n    fi\n    removeSoftLinkAndCreateDir
    \"${backupDir}/replicatorYamlFile\" \"${effectiveUser}\" \"${effectiveGroup}\"
    \"yes\"\n    removeFileOperation \"${backupDir}/replicatorYamlFile\" \"${replicatorRtYamlFile}\"\n}\n\nbackupFiles_hook
    () {\n    local backupDirectory=\"$1\" \n    _createBackupOfLogBackDir \"${backupDirectory}\"\n
    \   _createBackupOfReplicatorRtYaml \"${backupDirectory}\"\n}\n\nmigrateArtifactory
    () {\n    creationMigrateLog\n    _pauseExecution \"creationMigrateLog\"\n    checkArtifactoryVersion\n
    \   _pauseExecution \"checkArtifactoryVersion\"\n    startMigration\n    _pauseExecution
    \"startMigration\"\n    setSystemYamlPath\n    _pauseExecution \"setSystemYamlPath\"\n
    \   createRequiredDirs\n    _pauseExecution \"createRequiredDirs\"\n    symlinkDirectories\n
    \   _pauseExecution \"symlinkDirectories\"\n    copyDirectories\n    _pauseExecution
    \"copyDirectories\"\n    moveDirectories\n    _pauseExecution \"moveDirectories\"\n
    \   trimMasterKey\n    _pauseExecution \"trimMasterKey\"\n    migratePropertiesFiles\n
    \   _pauseExecution \"migratePropertiesFiles\"\n    migrateXmlFile\n    _pauseExecution
    \"migrateXmlFile\"\n    migrateDefaultFile\n    _pauseExecution \"migrateDefaultFile\"\n
    \   migrateYamlFile\n    _pauseExecution \"migrateYamlFile\"\n    updateSystemYamlFile\n
    \   _pauseExecution \"updateSystemYamlFile\"\n    cleanUpOldDataDirectories\n
    \   _pauseExecution \"cleanUpOldDataDirectories\"\n    cleanUpOldFiles\n    _pauseExecution
    \"cleanUpOldFiles\"\n    commentNodeId\n    _pauseExecution \"commentNodeId\"\n
    \   artifactoryInfoMessage\n    _pauseExecution \"artifactoryInfoMessage\"\n    endMigration\n
    \   _pauseExecution \"endMigration\"\n}\n\ninitialize\nmain\n    \n"
  migrationHelmInfo.yaml: |
    migration:
     product: ARTIFACTORY
     oldDataDir: /var/opt/jfrog/artifactory
     moveDirectories:
       map:
       # Note : $JF_ROOT_DATA_DIR will be prepended to the sourceDirectoryPath value only if relative path and $JF_ROOT_DATA_DIR/var will be prepended to the targetDirectoryPath value
       # map should be in format example: targetDirectoryPath=sourceDirectoryPath
         backup/access=access/backup
         etc/access=access/etc
         data/access=access/data
         work/access=access/tmp
         log/archived/access=access/logs
         log/archived/artifactory=logs
         etc/replicator=replicator/etc
         backup/replicator=replicator/backup
         data/replicator=replicator/data
         log/archived/replicator=replicator/logs
     linkFiles:
       map:
       # Note : $JF_ROOT_DATA_DIR will be prepended to the sourceDirectoryPath value only if relative path and $JF_ROOT_DATA_DIR will be prepended to the targetDirectoryPath value
       # map should be in format example: targetDirectoryPath=sourceDirectoryPath
         etc/artifactory=etc
         backup/artifactory=backup
         data/artifactory=data
         support/artifactory=support
     cleanUpOldDataDir:
       # Note $JF_ROOT_DATA_DIR will be prepended to the map entry
       map:
         access
         replicator
         metadata
         logs
  migrationStatus.sh: "#!/bin/bash\nscriptsPath=\"/opt/jfrog/artifactory/app/bin\"\n\nstatusCheck(){\nretries=0\n#
    Max Timeout in seconds  default ~3600\nMaxRetries=$(expr 3600 / 10)\n# Wait for
    DB to start \nsleep 30\nuntil [ \"`curl -s -o /dev/null -w \"%{http_code}\" http://127.0.0.1:8082/router/api/v1/system/health`\"
    == \"200\" ];\ndo\n    echo Waiting for Artifactory to start --- sleeping for
    10 seconds\n    if [ $retries -eq $MaxRetries ]  \n    then \n    echo Failed
    to start.\n    exit 1\n    fi\n    retries=$(expr $retries + 1)\n    sleep 10\ndone\n\nsleep
    20\necho \"Artifactory started sucessfully...in Init Container\"\necho \"Stopping
    artifactory in Init Container...\"\n${scriptsPath}/artifactory.sh stop\necho \"Exiting
    Init Container...\"\n\n}\n\nbash ${scriptsPath}/migrate.sh $1\nstatus=$?\nif [[
    $status -eq 1 && -f /tmp/error ]]; then\n    echo \"Migration is not supported
    ...Exiting Init Container\"\n    exit 1\nelif [[ $status -eq 0 ]]; then\n    echo
    \"Waiting for Artifactory to start in Init Container\"\n    /entrypoint-artifactory.sh
    &\n    statusCheck\nelse\n    echo \"Migration not necessary...Exiting Init Container\"\n
    \   exit 0\nfi\n"
